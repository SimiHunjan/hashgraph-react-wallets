import { AccountBalanceQuery, Hbar, TransferTransaction, TokenAssociateTransaction, PrivateKey, AccountCreateTransaction, AccountInfoQuery, AccountDeleteTransaction, AccountUpdateTransaction, AccountId, ContractId, TokenId, TopicId, ContractCallQuery, ContractExecuteTransaction, TransactionId, ContractInfoQuery, ContractDeleteTransaction, Client, Transaction, AccountRecordsQuery, TransactionReceiptQuery, Wallet, Status, FileAppendTransaction, FileCreateTransaction, FileId, FileInfoQuery, FileDeleteTransaction, FileUpdateTransaction, FileContentsQuery, TransactionResponse, TransactionRecordQuery, TokenType as TokenType$1, TokenCreateTransaction, TokenUpdateTransaction, Key, TokenInfoQuery, TokenDeleteTransaction, TopicCreateTransaction, TopicInfoQuery, TopicDeleteTransaction, TopicUpdateTransaction, TopicMessageSubmitTransaction, ContractCreateTransaction } from './hashgraph-sdk.js';
import BigNumber$1 from 'https://unpkg.com/bignumber.js@9.0.2/bignumber.mjs';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var events = {exports: {}};

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };

var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
var once_1 = events.exports.once = once$1;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once$1(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

var EventEmitter$1 = events.exports;

var bn = {exports: {}};

(function (module) {
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})('object' === 'undefined' || module, commonjsGlobal);
}(bn));

var _BN = bn.exports;

const version$9 = "logger/5.7.0";

"use strict";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ///////////////////
    // Interaction Errors
    // The user rejected the action, such as signing a message or sending
    // a transaction
    ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
;
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                const fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (message == null) {
            message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version$9);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

const version$8 = "bytes/5.7.0";

"use strict";
const logger$d = new Logger(version$8);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));
}
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$d.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0" + hex;
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger$d.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        const result = [];
        for (let i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger$d.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map(item => arrayify(item));
    const length = objects.reduce((accum, item) => (accum + item.length), 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) {
        return result;
    }
    // Find the first non-zero entry
    let start = 0;
    while (start < result.length && result[start] === 0) {
        start++;
    }
    // If we started with zeros, strip them
    if (start) {
        result = result.slice(start);
    }
    return result;
}
function zeroPad(value, length) {
    value = arrayify(value);
    if (value.length > length) {
        logger$d.throwArgumentError("value out of range", "value", arguments[0]);
    }
    const result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$d.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger$d.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger$d.throwArgumentError("invalid hexlify value", "value", value);
}
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        return null;
    }
    return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger$d.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexValue(value) {
    const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
    if (trimmed === "0x") {
        return "0x0";
    }
    return trimmed;
}
function hexStripZeros(value) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    if (!isHexString(value)) {
        logger$d.throwArgumentError("invalid hex string", "value", value);
    }
    value = value.substring(2);
    let offset = 0;
    while (offset < value.length && value[offset] === "0") {
        offset++;
    }
    return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger$d.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger$d.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}
function splitSignature(signature) {
    const result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (isBytesLike(signature)) {
        let bytes = arrayify(signature);
        // Get the r, s and v
        if (bytes.length === 64) {
            // EIP-2098; pull the v from the top bit of s and clear it
            result.v = 27 + (bytes[32] >> 7);
            bytes[32] &= 0x7f;
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
        }
        else if (bytes.length === 65) {
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
            result.v = bytes[64];
        }
        else {
            logger$d.throwArgumentError("invalid signature string", "signature", signature);
        }
        // Allow a recid to be used as the v
        if (result.v < 27) {
            if (result.v === 0 || result.v === 1) {
                result.v += 27;
            }
            else {
                logger$d.throwArgumentError("signature invalid v byte", "signature", signature);
            }
        }
        // Compute recoveryParam from v
        result.recoveryParam = 1 - (result.v % 2);
        // Compute _vs from recoveryParam and s
        if (result.recoveryParam) {
            bytes[32] |= 0x80;
        }
        result._vs = hexlify(bytes.slice(32, 64));
    }
    else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        // If the _vs is available, use it to populate missing s, v and recoveryParam
        // and verify non-missing s, v and recoveryParam
        if (result._vs != null) {
            const vs = zeroPad(arrayify(result._vs), 32);
            result._vs = hexlify(vs);
            // Set or check the recid
            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);
            if (result.recoveryParam == null) {
                result.recoveryParam = recoveryParam;
            }
            else if (result.recoveryParam !== recoveryParam) {
                logger$d.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
            }
            // Set or check the s
            vs[0] &= 0x7f;
            const s = hexlify(vs);
            if (result.s == null) {
                result.s = s;
            }
            else if (result.s !== s) {
                logger$d.throwArgumentError("signature v mismatch _vs", "signature", signature);
            }
        }
        // Use recid and v to populate each other
        if (result.recoveryParam == null) {
            if (result.v == null) {
                logger$d.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
            }
            else if (result.v === 0 || result.v === 1) {
                result.recoveryParam = result.v;
            }
            else {
                result.recoveryParam = 1 - (result.v % 2);
            }
        }
        else {
            if (result.v == null) {
                result.v = 27 + result.recoveryParam;
            }
            else {
                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));
                if (result.recoveryParam !== recId) {
                    logger$d.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
                }
            }
        }
        if (result.r == null || !isHexString(result.r)) {
            logger$d.throwArgumentError("signature missing or invalid r", "signature", signature);
        }
        else {
            result.r = hexZeroPad(result.r, 32);
        }
        if (result.s == null || !isHexString(result.s)) {
            logger$d.throwArgumentError("signature missing or invalid s", "signature", signature);
        }
        else {
            result.s = hexZeroPad(result.s, 32);
        }
        const vs = arrayify(result.s);
        if (vs[0] >= 128) {
            logger$d.throwArgumentError("signature s out of range", "signature", signature);
        }
        if (result.recoveryParam) {
            vs[0] |= 0x80;
        }
        const _vs = hexlify(vs);
        if (result._vs) {
            if (!isHexString(result._vs)) {
                logger$d.throwArgumentError("signature invalid _vs", "signature", signature);
            }
            result._vs = hexZeroPad(result._vs, 32);
        }
        // Set or check the _vs
        if (result._vs == null) {
            result._vs = _vs;
        }
        else if (result._vs !== _vs) {
            logger$d.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
        }
    }
    result.yParityAndS = result._vs;
    result.compact = result.r + result.yParityAndS.substring(2);
    return result;
}
function joinSignature(signature) {
    signature = splitSignature(signature);
    return hexlify(concat([
        signature.r,
        signature.s,
        (signature.recoveryParam ? "0x1c" : "0x1b")
    ]));
}

const version$7 = "bignumber/5.7.0";

"use strict";
var BN = _BN.BN;
const logger$c = new Logger(version$7);
const _constructorGuard$2 = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return (value != null) && (BigNumber.isBigNumber(value) ||
        (typeof (value) === "number" && (value % 1) === 0) ||
        (typeof (value) === "string" && !!value.match(/^-?[0-9]+$/)) ||
        isHexString(value) ||
        (typeof (value) === "bigint") ||
        isBytes(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard$2) {
            logger$c.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault$1("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault$1("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault$1("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault$1("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault$1("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault$1("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault$1("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault$1("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault$1("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault$1("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger$c.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger$c.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger$c.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger$c.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard$2, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard$2, toHex(new BN(value)));
            }
            return logger$c.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault$1("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault$1("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
            return BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if (isHexString(hex) || (hex[0] === "-" && isHexString(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger$c.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger$c.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault$1(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger$c.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}
// value should have no prefix
function _base16To36(value) {
    return (new BN(value, 16)).toString(36);
}

"use strict";
const logger$b = new Logger(version$7);
const _constructorGuard$1 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value !== undefined) {
        params.value = value;
    }
    return logger$b.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
let zeros = "0";
while (zeros.length < 256) {
    zeros += zeros;
}
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
    if (typeof (decimals) !== "number") {
        try {
            decimals = BigNumber.from(decimals).toNumber();
        }
        catch (e) { }
    }
    if (typeof (decimals) === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
        return ("1" + zeros.substring(0, decimals));
    }
    return logger$b.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    // Make sure wei is a big number (convert as necessary)
    value = BigNumber.from(value);
    const negative = value.lt(Zero$2);
    if (negative) {
        value = value.mul(NegativeOne$2);
    }
    let fraction = value.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
        fraction = "0" + fraction;
    }
    // Strip training 0
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value.div(multiplier).toString();
    if (multiplier.length === 1) {
        value = whole;
    }
    else {
        value = whole + "." + fraction;
    }
    if (negative) {
        value = "-" + value;
    }
    return value;
}
function parseFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    if (typeof (value) !== "string" || !value.match(/^-?[0-9.]+$/)) {
        logger$b.throwArgumentError("invalid decimal value", "value", value);
    }
    // Is it negative?
    const negative = (value.substring(0, 1) === "-");
    if (negative) {
        value = value.substring(1);
    }
    if (value === ".") {
        logger$b.throwArgumentError("missing value", "value", value);
    }
    // Split it into a whole and fractional part
    const comps = value.split(".");
    if (comps.length > 2) {
        logger$b.throwArgumentError("too many decimal points", "value", value);
    }
    let whole = comps[0], fraction = comps[1];
    if (!whole) {
        whole = "0";
    }
    if (!fraction) {
        fraction = "0";
    }
    // Trim trailing zeros
    while (fraction[fraction.length - 1] === "0") {
        fraction = fraction.substring(0, fraction.length - 1);
    }
    // Check the fraction doesn't exceed our decimals size
    if (fraction.length > multiplier.length - 1) {
        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    }
    // If decimals is 0, we have an empty string for fraction
    if (fraction === "") {
        fraction = "0";
    }
    // Fully pad the string with zeros to get to wei
    while (fraction.length < multiplier.length - 1) {
        fraction += "0";
    }
    const wholeValue = BigNumber.from(whole);
    const fractionValue = BigNumber.from(fraction);
    let wei = (wholeValue.mul(multiplier)).add(fractionValue);
    if (negative) {
        wei = wei.mul(NegativeOne$2);
    }
    return wei;
}
class FixedFormat {
    constructor(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard$1) {
            logger$b.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
    }
    static from(value) {
        if (value instanceof FixedFormat) {
            return value;
        }
        if (typeof (value) === "number") {
            value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof (value) === "string") {
            if (value === "fixed") {
                // defaults...
            }
            else if (value === "ufixed") {
                signed = false;
            }
            else {
                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                if (!match) {
                    logger$b.throwArgumentError("invalid fixed format", "format", value);
                }
                signed = (match[1] !== "u");
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
            }
        }
        else if (value) {
            const check = (key, type, defaultValue) => {
                if (value[key] == null) {
                    return defaultValue;
                }
                if (typeof (value[key]) !== type) {
                    logger$b.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
                }
                return value[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
            logger$b.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
            logger$b.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat(_constructorGuard$1, signed, width, decimals);
    }
}
class FixedNumber {
    constructor(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard$1) {
            logger$b.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
    }
    _checkFormat(other) {
        if (this.format.name !== other.format.name) {
            logger$b.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
    }
    addUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
    }
    subUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
    }
    floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
            result = result.subUnsafe(ONE$1.toFormat(result.format));
        }
        return result;
    }
    ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
            result = result.addUnsafe(ONE$1.toFormat(result.format));
        }
        return result;
    }
    // @TODO: Support other rounding algorithms
    round(decimals) {
        if (decimals == null) {
            decimals = 0;
        }
        // If we are already in range, we're done
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || (decimals % 1)) {
            logger$b.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
            return this;
        }
        const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
        return (this._value === "0.0" || this._value === "0");
    }
    isNegative() {
        return (this._value[0] === "-");
    }
    toString() { return this._value; }
    toHexString(width) {
        if (width == null) {
            return this._hex;
        }
        if (width % 8) {
            logger$b.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return hexZeroPad(hex, width / 8);
    }
    toUnsafeFloat() { return parseFloat(this.toString()); }
    toFormat(format) {
        return FixedNumber.fromString(this._value, format);
    }
    static fromValue(value, decimals, format) {
        // If decimals looks more like a format, and there is no format, shift the parameters
        if (format == null && decimals != null && !isBigNumberish(decimals)) {
            format = decimals;
            decimals = null;
        }
        if (decimals == null) {
            decimals = 0;
        }
        if (format == null) {
            format = "fixed";
        }
        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    }
    static fromString(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero$2)) {
            throwFault("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
            hex = numeric.toTwos(fixedFormat.width).toHexString();
        }
        else {
            hex = numeric.toHexString();
            hex = hexZeroPad(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard$1, hex, decimal, fixedFormat);
    }
    static fromBytes(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (arrayify(value).length > fixedFormat.width / 8) {
            throw new Error("overflow");
        }
        let numeric = BigNumber.from(value);
        if (fixedFormat.signed) {
            numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard$1, hex, decimal, fixedFormat);
    }
    static from(value, format) {
        if (typeof (value) === "string") {
            return FixedNumber.fromString(value, format);
        }
        if (isBytes(value)) {
            return FixedNumber.fromBytes(value, format);
        }
        try {
            return FixedNumber.fromValue(value, 0, format);
        }
        catch (error) {
            // Allow NUMERIC_FAULT to bubble up
            if (error.code !== Logger.errors.INVALID_ARGUMENT) {
                throw error;
            }
        }
        return logger$b.throwArgumentError("invalid FixedNumber value", "value", value);
    }
    static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
    }
}
const ONE$1 = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");

const version$6 = "properties/5.7.0";

"use strict";
var __awaiter$1 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$a = new Logger(version$6);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
function resolveProperties(object) {
    return __awaiter$1(this, void 0, void 0, function* () {
        const promises = Object.keys(object).map((key) => {
            const value = object[key];
            return Promise.resolve(value).then((v) => ({ key: key, value: v }));
        });
        const results = yield Promise.all(promises);
        return results.reduce((accum, result) => {
            accum[(result.key)] = result.value;
            return accum;
        }, {});
    });
}
function checkProperties(object, properties) {
    if (!object || typeof (object) !== "object") {
        logger$a.throwArgumentError("invalid object", "object", object);
    }
    Object.keys(object).forEach((key) => {
        if (!properties[key]) {
            logger$a.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
    });
}
function shallowCopy(object) {
    const result = {};
    for (const key in object) {
        result[key] = object[key];
    }
    return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            let value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger$a.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof (object) === "object") {
        const result = {};
        for (const key in object) {
            const value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger$a.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info) {
        for (const key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
}

const version$5 = "abi/5.7.0";

"use strict";
const logger$9 = new Logger(version$5);
;
const _constructorGuard = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        logger$9.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger$9.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i = 0; i < param.length; i++) {
        let c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        logger$9.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (let key in params) {
        defineReadOnly(object, key, params[key]);
    }
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$9.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$9.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            let result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.components) {
                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof (value) === "string") {
            return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(_constructorGuard, {
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
;
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$9.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === "string") {
            return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger$9.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(" ")[0] === "function") {
            return FunctionFragment.fromString(value.substring(8).trim());
        }
        else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(" ")[0] === "error") {
            return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger$9.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$9.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            logger$9.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
            logger$9.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger$9.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return (value && value._isFragment && value.type === "event");
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) {
            logger$9.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
            logger$9.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = BigNumber.from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                logger$9.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                logger$9.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger$9.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            logger$9.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        logger$9.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$9.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        if (format === FormatTypes.sighash) {
            logger$9.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            logger$9.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
            logger$9.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            logger$9.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return (value && value._isFragment && value.type === "constructor");
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$9.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
            }
            if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            logger$9.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
            logger$9.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
            logger$9.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                logger$9.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return (value && value._isFragment && value.type === "function");
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger$9.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$9.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            logger$9.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
            logger$9.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return (value && value._isFragment && value.type === "error");
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        logger$9.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    logger$9.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}

"use strict";
const logger$8 = new Logger(version$5);
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic) {
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger$8.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return hexConcat(this._data);
    }
    get length() { return this._dataLength; }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData(concat(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = arrayify(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = arrayify(BigNumber.from(value));
        if (bytes.length > this.wordSize) {
            logger$8.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes.length
            });
        }
        if (bytes.length % this.wordSize) {
            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() { return hexlify(this._data); }
    get consumed() { return this._offset; }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
        }
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) {
            return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                logger$8.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + alignedLength
                });
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
    }
}

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version$4 = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config$1 = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version$4,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config$1,
  uptime: uptime
};

var sha3$1 = {exports: {}};

(function (module) {
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof browser$1 === 'object' && browser$1.versions && browser$1.versions.node;
  if (NODE_JS) {
    root = commonjsGlobal;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
  var AMD = typeof undefined === 'function' && undefined.amd;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      undefined(function () {
        return methods;
      });
    }
  }
})();
}(sha3$1));

var sha3 = sha3$1.exports;

"use strict";
function keccak256(data) {
    return '0x' + sha3.keccak_256(arrayify(data));
}

const version$3 = "rlp/5.7.0";

"use strict";
const logger$7 = new Logger(version$3);
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!isBytesLike(object)) {
        logger$7.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call(arrayify(object));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode$1(object) {
    return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
            logger$7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) {
        logger$7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) {
            logger$7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger$7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) {
            logger$7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) {
            logger$7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger$7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) {
            logger$7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: hexlify(data[offset]) };
}
function decode$1(data) {
    const bytes = arrayify(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
        logger$7.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
}

const version$2 = "address/5.7.0";

"use strict";
const logger$6 = new Logger(version$2);
function getChecksumAddress(address) {
    if (!isHexString(address, 20)) {
        logger$6.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = arrayify(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
;
function getAddress(address) {
    let result = null;
    if (typeof (address) !== "string") {
        logger$6.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger$6.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger$6.throwArgumentError("bad icap checksum", "address", address);
        }
        result = _base36To16(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger$6.throwArgumentError("invalid address", "address", address);
    }
    return result;
}
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    }
    catch (error) { }
    return false;
}
function getIcapAddress(address) {
    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
    while (base36.length < 30) {
        base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
}
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
    let from = null;
    try {
        from = getAddress(transaction.from);
    }
    catch (error) {
        logger$6.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
    return getAddress(hexDataSlice(keccak256(encode$1([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
    if (hexDataLength(salt) !== 32) {
        logger$6.throwArgumentError("salt must be 32 bytes", "salt", salt);
    }
    if (hexDataLength(initCodeHash) !== 32) {
        logger$6.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    }
    return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from), salt, initCodeHash])), 12));
}

"use strict";
class AddressCoder extends Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = getAddress(value);
        }
        catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
    }
}

"use strict";
// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends Coder {
    constructor(coder) {
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

"use strict";
const logger$5 = new Logger(version$5);
function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            if (!name) {
                logger$5.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            if (unique[name]) {
                logger$5.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            unique[name] = true;
            return values[name];
        });
    }
    else {
        logger$5.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
        logger$5.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new Writer(writer.wordSize);
    let dynamicWriter = new Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value != undefined) {
            values.push(value);
        }
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
            return;
        }
        if (name === "length") {
            name = "_length";
        }
        if (values[name] != null) {
            return;
        }
        const value = values[index];
        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
        else {
            values[name] = value;
        }
    });
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
    }
    return Object.freeze(values);
}
class ArrayCoder extends Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger$5.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) {
                logger$5.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
                    length: reader._data.length,
                    count: count
                });
            }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
    }
}

"use strict";
class BooleanCoder extends Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}

"use strict";
class DynamicBytesCoder extends Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
    }
}

"use strict";
// @TODO: Merge this with bytes
class FixedBytesCoder extends Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = arrayify(value);
        if (data.length !== this.size) {
            this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
    }
}

"use strict";
class NullCoder extends Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}

const AddressZero = "0x0000000000000000000000000000000000000000";

const NegativeOne$1 = ( /*#__PURE__*/BigNumber.from(-1));
const Zero$1 = ( /*#__PURE__*/BigNumber.from(0));
const One$1 = ( /*#__PURE__*/BigNumber.from(1));
const Two = ( /*#__PURE__*/BigNumber.from(2));
const WeiPerEther = ( /*#__PURE__*/BigNumber.from("1000000000000000000"));
const MaxUint256$1 = ( /*#__PURE__*/BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
const MinInt256 = ( /*#__PURE__*/BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000"));
const MaxInt256 = ( /*#__PURE__*/BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

// NFKC (composed)             // (decomposed)
const EtherSymbol = "\u039e"; // "\uD835\uDF63";

"use strict";

"use strict";
class NumberCoder extends Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = BigNumber.from(value);
        // Check bounds are safe for encoding
        let maxUintValue = MaxUint256$1.mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(One$1).mul(NegativeOne$1))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(Zero$1) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}

const version$1 = "strings/5.7.0";

"use strict";
const logger$4 = new Logger(version$1);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
;
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
;
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger$4.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = arrayify(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            ;
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger$4.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return arrayify(result);
}
;
function escapeChar(value) {
    const hex = ("0000" + value.toString(16));
    return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
        if (codePoint < 256) {
            switch (codePoint) {
                case 8: return "\\b";
                case 9: return "\\t";
                case 10: return "\\n";
                case 13: return "\\r";
                case 34: return "\\\"";
                case 92: return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) {
                return String.fromCharCode(codePoint);
            }
        }
        if (codePoint <= 0xffff) {
            return escapeChar(codePoint);
        }
        codePoint -= 0x10000;
        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
    }).join("") + '"';
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}

"use strict";
function formatBytes32String(text) {
    // Get the bytes
    const bytes = toUtf8Bytes(text);
    // Check we have room for null-termination
    if (bytes.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
    }
    // Zero-pad (implicitly null-terminates)
    return hexlify(concat([bytes, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
    const data = arrayify(bytes);
    // Must be 32 bytes with a null-termination
    if (data.length !== 32) {
        throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data[31] !== 0) {
        throw new Error("invalid bytes32 string - no null terminator");
    }
    // Find the null termination
    let length = 31;
    while (data[length - 1] === 0) {
        length--;
    }
    // Determine the string value
    return toUtf8String(data.slice(0, length));
}

"use strict";
function bytes2(data) {
    if ((data.length % 4) !== 0) {
        throw new Error("bad data");
    }
    let result = [];
    for (let i = 0; i < data.length; i += 4) {
        result.push(parseInt(data.substring(i, i + 4), 16));
    }
    return result;
}
function createTable(data, func) {
    if (!func) {
        func = function (value) { return [parseInt(value, 16)]; };
    }
    let lo = 0;
    let result = {};
    data.split(",").forEach((pair) => {
        let comps = pair.split(":");
        lo += parseInt(comps[0], 16);
        result[lo] = func(comps[1]);
    });
    return result;
}
function createRangeTable(data) {
    let hi = 0;
    return data.split(",").map((v) => {
        let comps = v.split("-");
        if (comps.length === 1) {
            comps[1] = "0";
        }
        else if (comps[1] === "") {
            comps[1] = "1";
        }
        let lo = hi + parseInt(comps[0], 16);
        hi = parseInt(comps[1], 16);
        return { l: lo, h: hi };
    });
}
function matchMap(value, ranges) {
    let lo = 0;
    for (let i = 0; i < ranges.length; i++) {
        let range = ranges[i];
        lo += range.l;
        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {
            if (range.e && range.e.indexOf(value - lo) !== -1) {
                continue;
            }
            return range;
        }
    }
    return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
// @TODO: Make this relative...
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
const Table_B_2_ranges = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 }
];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
    return values.reduce((accum, value) => {
        value.forEach((value) => { accum.push(value); });
        return accum;
    }, []);
}
function _nameprepTableA1(codepoint) {
    return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
    let range = matchMap(codepoint, Table_B_2_ranges);
    if (range) {
        return [codepoint + range.s];
    }
    let codes = Table_B_2_lut_abs[codepoint];
    if (codes) {
        return codes;
    }
    let shift = Table_B_2_lut_rel[codepoint];
    if (shift) {
        return [codepoint + shift[0]];
    }
    let complex = Table_B_2_complex[codepoint];
    if (complex) {
        return complex;
    }
    return null;
}
function _nameprepTableC(codepoint) {
    return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
    // This allows platforms with incomplete normalize to bypass
    // it for very basic names which the built-in toLowerCase
    // will certainly handle correctly
    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
        return value.toLowerCase();
    }
    // Get the code points (keeping the current normalization)
    let codes = toUtf8CodePoints(value);
    codes = flatten(codes.map((code) => {
        // Substitute Table B.1 (Maps to Nothing)
        if (Table_B_1_flags.indexOf(code) >= 0) {
            return [];
        }
        if (code >= 0xfe00 && code <= 0xfe0f) {
            return [];
        }
        // Substitute Table B.2 (Case Folding)
        let codesTableB2 = _nameprepTableB2(code);
        if (codesTableB2) {
            return codesTableB2;
        }
        // No Substitution
        return [code];
    }));
    // Normalize using form KC
    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9
    codes.forEach((code) => {
        if (_nameprepTableC(code)) {
            throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
        }
    });
    // Prohibit Unassigned Code Points (Table A.1)
    codes.forEach((code) => {
        if (_nameprepTableA1(code)) {
            throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
        }
    });
    // IDNA extras
    let name = _toUtf8String(codes);
    // IDNA: 4.2.3.1
    if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
        throw new Error("invalid hyphen");
    }
    return name;
}

"use strict";

"use strict";
class StringCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
    }
    decode(reader) {
        return toUtf8String(super.decode(reader));
    }
}

"use strict";
class TupleCoder extends Coder {
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return pack(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
    }
}

"use strict";
const logger$3 = new Logger(version$5);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new AddressCoder(param.name);
            case "bool":
                return new BooleanCoder(param.name);
            case "string":
                return new StringCoder(param.name);
            case "bytes":
                return new BytesCoder(param.name);
            case "array":
                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new TupleCoder((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                logger$3.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                logger$3.throwArgumentError("invalid bytes length", "param", param);
            }
            return new FixedBytesCoder(size, param.name);
        }
        return logger$3.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new Writer(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            logger$3.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = (new TupleCoder(coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();

function id(text) {
    return keccak256(toUtf8Bytes(text));
}

const version = "hash/5.7.0";

"use strict";
function decode(textData) {
    textData = atob(textData);
    const data = [];
    for (let i = 0; i < textData.length; i++) {
        data.push(textData.charCodeAt(i));
    }
    return arrayify(data);
}
function encode(data) {
    data = arrayify(data);
    let textData = "";
    for (let i = 0; i < data.length; i++) {
        textData += String.fromCharCode(data[i]);
    }
    return btoa(textData);
}

"use strict";

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js
function flat(array, depth) {
    if (depth == null) {
        depth = 1;
    }
    const result = [];
    const forEach = result.forEach;
    const flatDeep = function (arr, depth) {
        forEach.call(arr, function (val) {
            if (depth > 0 && Array.isArray(val)) {
                flatDeep(val, depth - 1);
            }
            else {
                result.push(val);
            }
        });
    };
    flatDeep(array, depth);
    return result;
}
function fromEntries(array) {
    const result = {};
    for (let i = 0; i < array.length; i++) {
        const value = array[i];
        result[value[0]] = value[1];
    }
    return result;
}
function decode_arithmetic(bytes) {
    let pos = 0;
    function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }
    // decode the frequency table
    let symbol_count = u16();
    let total = 1;
    let acc = [0, 1]; // first symbol has frequency 1
    for (let i = 1; i < symbol_count; i++) {
        acc.push(total += u16());
    }
    // skip the sized-payload that the last 3 symbols index into
    let skip = u16();
    let pos_payload = pos;
    pos += skip;
    let read_width = 0;
    let read_buffer = 0;
    function read_bit() {
        if (read_width == 0) {
            // this will read beyond end of buffer
            // but (undefined|0) => zero pad
            read_buffer = (read_buffer << 8) | bytes[pos++];
            read_width = 8;
        }
        return (read_buffer >> --read_width) & 1;
    }
    const N = 31;
    const FULL = Math.pow(2, N);
    const HALF = FULL >>> 1;
    const QRTR = HALF >> 1;
    const MASK = FULL - 1;
    // fill register
    let register = 0;
    for (let i = 0; i < N; i++)
        register = (register << 1) | read_bit();
    let symbols = [];
    let low = 0;
    let range = FULL; // treat like a float
    while (true) {
        let value = Math.floor((((register - low + 1) * total) - 1) / range);
        let start = 0;
        let end = symbol_count;
        while (end - start > 1) { // binary search
            let mid = (start + end) >>> 1;
            if (value < acc[mid]) {
                end = mid;
            }
            else {
                start = mid;
            }
        }
        if (start == 0)
            break; // first symbol is end mark
        symbols.push(start);
        let a = low + Math.floor(range * acc[start] / total);
        let b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while (((a ^ b) & HALF) == 0) {
            register = (register << 1) & MASK | read_bit();
            a = (a << 1) & MASK;
            b = (b << 1) & MASK | 1;
        }
        while (a & ~b & QRTR) {
            register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();
            a = (a << 1) ^ HALF;
            b = ((b ^ HALF) << 1) | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
    }
    let offset = symbol_count - 4;
    return symbols.map(x => {
        switch (x - offset) {
            case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);
            case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);
            case 1: return offset + bytes[pos_payload++];
            default: return x - 1;
        }
    });
}
// returns an iterator which returns the next symbol
function read_payload(v) {
    let pos = 0;
    return () => v[pos++];
}
function read_compressed_payload(bytes) {
    return read_payload(decode_arithmetic(bytes));
}
// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) {
    return (i & 1) ? (~i >> 1) : (i >> 1);
}
function read_counts(n, next) {
    let v = Array(n);
    for (let i = 0; i < n; i++)
        v[i] = 1 + next();
    return v;
}
function read_ascending(n, next) {
    let v = Array(n);
    for (let i = 0, x = -1; i < n; i++)
        v[i] = x += 1 + next();
    return v;
}
function read_deltas(n, next) {
    let v = Array(n);
    for (let i = 0, x = 0; i < n; i++)
        v[i] = x += signed(next());
    return v;
}
function read_member_array(next, lookup) {
    let v = read_ascending(next(), next);
    let n = next();
    let vX = read_ascending(n, next);
    let vN = read_counts(n, next);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < vN[i]; j++) {
            v.push(vX[i] + j);
        }
    }
    return lookup ? v.map(x => lookup[x]) : v;
}
// returns array of 
// [x, ys] => single replacement rule
// [x, ys, n, dx, dx] => linear map
function read_mapped_map(next) {
    let ret = [];
    while (true) {
        let w = next();
        if (w == 0)
            break;
        ret.push(read_linear_table(w, next));
    }
    while (true) {
        let w = next() - 1;
        if (w < 0)
            break;
        ret.push(read_replacement_table(w, next));
    }
    return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
    let v = [];
    while (true) {
        let i = next();
        if (i == 0)
            break;
        v.push(i);
    }
    return v;
}
function read_transposed(n, w, next) {
    let m = Array(n).fill(undefined).map(() => []);
    for (let i = 0; i < w; i++) {
        read_deltas(n, next).forEach((x, j) => m[j].push(x));
    }
    return m;
}
function read_linear_table(w, next) {
    let dx = 1 + next();
    let dy = next();
    let vN = read_zero_terminated_array(next);
    let m = read_transposed(vN.length, 1 + w, next);
    return flat(m.map((v, i) => {
        const x = v[0], ys = v.slice(1);
        //let [x, ...ys] = v;
        //return Array(vN[i]).fill().map((_, j) => {
        return Array(vN[i]).fill(undefined).map((_, j) => {
            let j_dy = j * dy;
            return [x + j * dx, ys.map(y => y + j_dy)];
        });
    }));
}
function read_replacement_table(w, next) {
    let n = 1 + next();
    let m = read_transposed(n, 1 + w, next);
    return m.map(v => [v[0], v.slice(1)]);
}
function read_emoji_trie(next) {
    let sorted = read_member_array(next).sort((a, b) => a - b);
    return read();
    function read() {
        let branches = [];
        while (true) {
            let keys = read_member_array(next, sorted);
            if (keys.length == 0)
                break;
            branches.push({ set: new Set(keys), node: read() });
        }
        branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood
        let temp = next();
        let valid = temp % 3;
        temp = (temp / 3) | 0;
        let fe0f = !!(temp & 1);
        temp >>= 1;
        let save = temp == 1;
        let check = temp == 2;
        return { branches, valid, fe0f, save, check };
    }
}

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
function getData() {
    return read_compressed_payload(decode('AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=='));
}

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
const r = getData();
// @TODO: This should be lazily loaded
const VALID = new Set(read_member_array(r));
const IGNORED = new Set(read_member_array(r));
const MAPPED = read_mapped_map(r);
const EMOJI_ROOT = read_emoji_trie(r);
//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));
//const STOP = 0x2E;
const HYPHEN = 0x2D;
const UNDERSCORE = 0x5F;
function explode_cp(name) {
    return toUtf8CodePoints(name);
}
function filter_fe0f(cps) {
    return cps.filter(cp => cp != 0xFE0F);
}
function ens_normalize_post_check(name) {
    for (let label of name.split('.')) {
        let cps = explode_cp(label);
        try {
            for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
                if (cps[i] !== UNDERSCORE) {
                    throw new Error(`underscore only allowed at start`);
                }
            }
            if (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
                throw new Error(`invalid label extension`);
            }
        }
        catch (err) {
            throw new Error(`Invalid label "${label}": ${err.message}`);
        }
    }
    return name;
}
function ens_normalize(name) {
    return ens_normalize_post_check(normalize(name, filter_fe0f));
}
function normalize(name, emoji_filter) {
    let input = explode_cp(name).reverse(); // flip for pop
    let output = [];
    while (input.length) {
        let emoji = consume_emoji_reversed(input);
        if (emoji) {
            output.push(...emoji_filter(emoji));
            continue;
        }
        let cp = input.pop();
        if (VALID.has(cp)) {
            output.push(cp);
            continue;
        }
        if (IGNORED.has(cp)) {
            continue;
        }
        let cps = MAPPED[cp];
        if (cps) {
            output.push(...cps);
            continue;
        }
        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
    }
    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s) {
    return s.normalize('NFC');
}
function consume_emoji_reversed(cps, eaten) {
    var _a;
    let node = EMOJI_ROOT;
    let emoji;
    let saved;
    let stack = [];
    let pos = cps.length;
    if (eaten)
        eaten.length = 0; // clear input buffer (if needed)
    while (pos) {
        let cp = cps[--pos];
        node = (_a = node.branches.find(x => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;
        if (!node)
            break;
        if (node.save) { // remember
            saved = cp;
        }
        else if (node.check) { // check exclusion
            if (cp === saved)
                break;
        }
        stack.push(cp);
        if (node.fe0f) {
            stack.push(0xFE0F);
            if (pos > 0 && cps[pos - 1] == 0xFE0F)
                pos--; // consume optional FE0F
        }
        if (node.valid) { // this is a valid emoji (so far)
            emoji = stack.slice(); // copy stack
            if (node.valid == 2)
                emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)
            if (eaten)
                eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)
            cps.length = pos; // truncate
        }
    }
    return emoji;
}

const logger$2 = new Logger(version);
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
    if (comp.length === 0) {
        throw new Error("invalid ENS name; empty component");
    }
    return comp;
}
function ensNameSplit(name) {
    const bytes = toUtf8Bytes(ens_normalize(name));
    const comps = [];
    if (name.length === 0) {
        return comps;
    }
    let last = 0;
    for (let i = 0; i < bytes.length; i++) {
        const d = bytes[i];
        // A separator (i.e. "."); copy this component
        if (d === 0x2e) {
            comps.push(checkComponent(bytes.slice(last, i)));
            last = i + 1;
        }
    }
    // There was a stray separator at the end of the name
    if (last >= bytes.length) {
        throw new Error("invalid ENS name; empty component");
    }
    comps.push(checkComponent(bytes.slice(last)));
    return comps;
}
function ensNormalize(name) {
    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(".");
}
function isValidName(name) {
    try {
        return (ensNameSplit(name).length !== 0);
    }
    catch (error) { }
    return false;
}
function namehash(name) {
    /* istanbul ignore if */
    if (typeof (name) !== "string") {
        logger$2.throwArgumentError("invalid ENS name; not a string", "name", name);
    }
    let result = Zeros;
    const comps = ensNameSplit(name);
    while (comps.length) {
        result = keccak256(concat([result, keccak256(comps.pop())]));
    }
    return hexlify(result);
}
function dnsEncode(name) {
    return hexlify(concat(ensNameSplit(name).map((comp) => {
        // DNS does not allow components over 63 bytes in length
        if (comp.length > 63) {
            throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        }
        const bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
    }))) + "00";
}

const messagePrefix = "\x19Ethereum Signed Message:\n";
function hashMessage(message) {
    if (typeof (message) === "string") {
        message = toUtf8Bytes(message);
    }
    return keccak256(concat([
        toUtf8Bytes(messagePrefix),
        toUtf8Bytes(String(message.length)),
        message
    ]));
}

var __awaiter = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$1 = new Logger(version);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
    const bytes = arrayify(value);
    const padOffset = bytes.length % 32;
    if (padOffset) {
        return hexConcat([bytes, padding.slice(padOffset)]);
    }
    return hexlify(bytes);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
};
const domainFieldNames = [
    "name", "version", "chainId", "verifyingContract", "salt"
];
function checkString(key) {
    return function (value) {
        if (typeof (value) !== "string") {
            logger$1.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
        }
        return value;
    };
}
const domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function (value) {
        try {
            return BigNumber.from(value).toString();
        }
        catch (error) { }
        return logger$1.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
    },
    verifyingContract: function (value) {
        try {
            return getAddress(value).toLowerCase();
        }
        catch (error) { }
        return logger$1.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function (value) {
        try {
            const bytes = arrayify(value);
            if (bytes.length !== 32) {
                throw new Error("bad length");
            }
            return hexlify(bytes);
        }
        catch (error) { }
        return logger$1.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
    }
};
function getBaseEncoder(type) {
    // intXX and uintXX
    {
        const match = type.match(/^(u?)int(\d*)$/);
        if (match) {
            const signed = (match[1] === "");
            const width = parseInt(match[2] || "256");
            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {
                logger$1.throwArgumentError("invalid numeric width", "type", type);
            }
            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);
            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
            return function (value) {
                const v = BigNumber.from(value);
                if (v.lt(boundsLower) || v.gt(boundsUpper)) {
                    logger$1.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
                }
                return hexZeroPad(v.toTwos(256).toHexString(), 32);
            };
        }
    }
    // bytesXX
    {
        const match = type.match(/^bytes(\d+)$/);
        if (match) {
            const width = parseInt(match[1]);
            if (width === 0 || width > 32 || match[1] !== String(width)) {
                logger$1.throwArgumentError("invalid bytes width", "type", type);
            }
            return function (value) {
                const bytes = arrayify(value);
                if (bytes.length !== width) {
                    logger$1.throwArgumentError(`invalid length for ${type}`, "value", value);
                }
                return hexPadRight(value);
            };
        }
    }
    switch (type) {
        case "address": return function (value) {
            return hexZeroPad(getAddress(value), 32);
        };
        case "bool": return function (value) {
            return ((!value) ? hexFalse : hexTrue);
        };
        case "bytes": return function (value) {
            return keccak256(value);
        };
        case "string": return function (value) {
            return id(value);
        };
    }
    return null;
}
function encodeType(name, fields) {
    return `${name}(${fields.map(({ name, type }) => (type + " " + name)).join(",")})`;
}
class TypedDataEncoder {
    constructor(types) {
        defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
        defineReadOnly(this, "_encoderCache", {});
        defineReadOnly(this, "_types", {});
        // Link struct types to their direct child structs
        const links = {};
        // Link structs to structs which contain them as a child
        const parents = {};
        // Link all subtypes within a given struct
        const subtypes = {};
        Object.keys(types).forEach((type) => {
            links[type] = {};
            parents[type] = [];
            subtypes[type] = {};
        });
        for (const name in types) {
            const uniqueNames = {};
            types[name].forEach((field) => {
                // Check each field has a unique name
                if (uniqueNames[field.name]) {
                    logger$1.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
                }
                uniqueNames[field.name] = true;
                // Get the base type (drop any array specifiers)
                const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                if (baseType === name) {
                    logger$1.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
                }
                // Is this a base encoding type?
                const encoder = getBaseEncoder(baseType);
                if (encoder) {
                    return;
                }
                if (!parents[baseType]) {
                    logger$1.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
                }
                // Add linkage
                parents[baseType].push(name);
                links[name][baseType] = true;
            });
        }
        // Deduce the primary type
        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));
        if (primaryTypes.length === 0) {
            logger$1.throwArgumentError("missing primary type", "types", types);
        }
        else if (primaryTypes.length > 1) {
            logger$1.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(", ")}`, "types", types);
        }
        defineReadOnly(this, "primaryType", primaryTypes[0]);
        // Check for circular type references
        function checkCircular(type, found) {
            if (found[type]) {
                logger$1.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
            }
            found[type] = true;
            Object.keys(links[type]).forEach((child) => {
                if (!parents[child]) {
                    return;
                }
                // Recursively check children
                checkCircular(child, found);
                // Mark all ancestors as having this decendant
                Object.keys(found).forEach((subtype) => {
                    subtypes[subtype][child] = true;
                });
            });
            delete found[type];
        }
        checkCircular(this.primaryType, {});
        // Compute each fully describe type
        for (const name in subtypes) {
            const st = Object.keys(subtypes[name]);
            st.sort();
            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join("");
        }
    }
    getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) {
            encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
    }
    _getEncoder(type) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return encoder;
            }
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const subEncoder = this.getEncoder(subtype);
            const length = parseInt(match[3]);
            return (value) => {
                if (length >= 0 && value.length !== length) {
                    logger$1.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
                }
                let result = value.map(subEncoder);
                if (this._types[subtype]) {
                    result = result.map(keccak256);
                }
                return keccak256(hexConcat(result));
            };
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            const encodedType = id(this._types[type]);
            return (value) => {
                const values = fields.map(({ name, type }) => {
                    const result = this.getEncoder(type)(value[name]);
                    if (this._types[type]) {
                        return keccak256(result);
                    }
                    return result;
                });
                values.unshift(encodedType);
                return hexConcat(values);
            };
        }
        return logger$1.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    encodeType(name) {
        const result = this._types[name];
        if (!result) {
            logger$1.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
        }
        return result;
    }
    encodeData(type, value) {
        return this.getEncoder(type)(value);
    }
    hashStruct(name, value) {
        return keccak256(this.encodeData(name, value));
    }
    encode(value) {
        return this.encodeData(this.primaryType, value);
    }
    hash(value) {
        return this.hashStruct(this.primaryType, value);
    }
    _visit(type, value, callback) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return callback(type, value);
            }
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const length = parseInt(match[3]);
            if (length >= 0 && value.length !== length) {
                logger$1.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            return value.map((v) => this._visit(subtype, v, callback));
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            return fields.reduce((accum, { name, type }) => {
                accum[name] = this._visit(type, value[name], callback);
                return accum;
            }, {});
        }
        return logger$1.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
    }
    static from(types) {
        return new TypedDataEncoder(types);
    }
    static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
    }
    static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
            const type = domainFieldTypes[name];
            if (!type) {
                logger$1.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            }
            domainFields.push({ name, type });
        }
        domainFields.sort((a, b) => {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
    }
    static encode(domain, types, value) {
        return hexConcat([
            "0x1901",
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value)
        ]);
    }
    static hash(domain, types, value) {
        return keccak256(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    static resolveNames(domain, types, value, resolveName) {
        return __awaiter(this, void 0, void 0, function* () {
            // Make a copy to isolate it from the object passed in
            domain = shallowCopy(domain);
            // Look up all ENS names
            const ensCache = {};
            // Do we need to look up the domain's verifyingContract?
            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
                ensCache[domain.verifyingContract] = "0x";
            }
            // We are going to use the encoder to visit all the base values
            const encoder = TypedDataEncoder.from(types);
            // Get a list of all the addresses
            encoder.visit(value, (type, value) => {
                if (type === "address" && !isHexString(value, 20)) {
                    ensCache[value] = "0x";
                }
                return value;
            });
            // Lookup each name
            for (const name in ensCache) {
                ensCache[name] = yield resolveName(name);
            }
            // Replace the domain verifyingContract if needed
            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                domain.verifyingContract = ensCache[domain.verifyingContract];
            }
            // Replace all ENS names with their address
            value = encoder.visit(value, (type, value) => {
                if (type === "address" && ensCache[value]) {
                    return ensCache[value];
                }
                return value;
            });
            return { domain, value };
        });
    }
    static getPayload(domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name) => {
            const value = domain[name];
            if (value == null) {
                return;
            }
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder = TypedDataEncoder.from(types);
        const typesWithDomain = shallowCopy(types);
        if (typesWithDomain.EIP712Domain) {
            logger$1.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        }
        else {
            typesWithDomain.EIP712Domain = domainTypes;
        }
        // Validate the data structures and types
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value) => {
                // bytes
                if (type.match(/^bytes(\d*)/)) {
                    return hexlify(arrayify(value));
                }
                // uint or int
                if (type.match(/^u?int/)) {
                    return BigNumber.from(value).toString();
                }
                switch (type) {
                    case "address":
                        return value.toLowerCase();
                    case "bool":
                        return !!value;
                    case "string":
                        if (typeof (value) !== "string") {
                            logger$1.throwArgumentError(`invalid string`, "value", value);
                        }
                        return value;
                }
                return logger$1.throwArgumentError("unsupported type", "type", type);
            })
        };
    }
}

"use strict";

"use strict";
const logger = new Logger(version$5);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
            return Fragment.from(fragment);
        }).filter((fragment) => (fragment != null)));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment) => {
            let bucket = null;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        logger.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    defineReadOnly(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            defineReadOnly(this, "deploy", ConstructorFragment.from({
                payable: false,
                type: "constructor"
            }));
        }
        defineReadOnly(this, "_isInterface", true);
    }
    format(format) {
        if (!format) {
            format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
            logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === FormatTypes.json) {
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return defaultAbiCoder;
    }
    static getAddress(address) {
        return getAddress(address);
    }
    static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return id(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            for (const name in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name)) {
                    return this.functions[name];
                }
            }
            logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching function", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching functions", "name", name);
            }
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for (const name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            logger.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching event", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching events", "name", name);
            }
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            const getSighash = getStatic(this.constructor, "getSighash");
            for (const name in this.errors) {
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                    return this.errors[name];
                }
            }
            logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching error", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching errors", "name", name);
            }
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof (fragment) === "string") {
            try {
                fragment = this.getFunction(fragment);
            }
            catch (error) {
                try {
                    fragment = this.getError(fragment);
                }
                catch (_) {
                    throw error;
                }
            }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        return hexlify(concat([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                }
                catch (error) { }
                break;
            case 4: {
                const selector = hexlify(bytes.slice(0, 4));
                const builtin = BuiltinErrors[selector];
                if (builtin) {
                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                    errorName = builtin.name;
                    errorSignature = builtin.signature;
                    if (builtin.reason) {
                        reason = errorArgs[0];
                    }
                    if (errorName === "Error") {
                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
                    }
                    else if (errorName === "Panic") {
                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
                    }
                }
                else {
                    try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    }
                    catch (error) { }
                }
                break;
            }
        }
        return logger.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: hexlify(data), errorArgs, errorName, errorSignature, reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
            logger.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
            });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return id(value);
            }
            else if (param.type === "bytes") {
                return keccak256(hexlify(value));
            }
            if (param.type === "bool" && typeof (value) === "boolean") {
                value = (value ? "0x01" : "0x00");
            }
            if (param.type.match(/^u?int/)) {
                value = BigNumber.from(value).toHexString();
            }
            // Check addresses are valid
            if (param.type === "address") {
                this._abiCoder.encode(["address"], [value]);
            }
            return hexZeroPad(hexlify(value), 32);
        };
        values.forEach((value, index) => {
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) {
                    logger.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                }
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
            logger.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push(id(value));
                }
                else if (param.type === "bytes") {
                    topics.push(keccak256(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                logger.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = new Indexed({ _isIndexed: true, hash: null });
                }
                else if (dynamic[index]) {
                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                }
                else {
                    try {
                        result[index] = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        result[index] = error;
                    }
                }
            }
            else {
                try {
                    result[index] = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    result[index] = error;
                }
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) {
                    Object.defineProperty(result, param.name, {
                        enumerable: true,
                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }
                    });
                }
                else {
                    result[param.name] = value;
                }
            }
        });
        // Make all error indexed values throw on access
        for (let i = 0; i < result.length; i++) {
            const value = result[i];
            if (value instanceof Error) {
                Object.defineProperty(result, i, {
                    enumerable: true,
                    get: () => { throw wrapAccessError(`index ${i}`, value); }
                });
            }
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: BigNumber.from(tx.value || "0"),
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = hexlify(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
        return !!(value && value._isInterface);
    }
}

"use strict";

var long = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};

var traverse$2 = {exports: {}};

var traverse = traverse$2.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f; },
            after : function (f) { modifiers.after = f; },
            pre : function (f) { modifiers.pre = f; },
            post : function (f) { modifiers.post = f; },
            stop : function () { alive = false; },
            block : function () { keepGoing = false; }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node);
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

var traverse$1 = traverse$2.exports;

function isSolidityAddressable(arg) {
  return arg && arg.getSolidityAddress && typeof arg.getSolidityAddress === "function";
}
function extractSolidityAddressFrom(addr) {
  const matchedExp = /^(?:0x)?([0-9a-fA-F]{40})$/g.exec(addr);
  return matchedExp != undefined ? matchedExp[1] : undefined;
}

/**
 * Common functionality exhibited by session-bounded, identifiable LiveEntity instances.
 */
class LiveEntity {
  /**
   * Sanity flag which, when true, signifies that the live-entity is still operating on the hashgraph (default) while,
   * if false, the fact that no further network operations are possible on the underlying entity. This is usually the case
   * following a self-delete operation.
   */
  isSane = true;
  constructor(session, id) {
    this.session = session;
    this.id = id;
  }
  get log() {
    return this.session.log;
  }
  equals(what) {
    if (what instanceof LiveEntity) {
      return what.id.toSolidityAddress() === this.id.toSolidityAddress();
    }
    return this._equals(what);
  }
  async deleteEntity(args) {
    const transaction = await this._getDeleteTransaction(args);
    const deleteTransactionResponse = await this.sanelyExecuteAndGetStatus(transaction);
    this.isSane = false;
    return deleteTransactionResponse;
  }
  async updateEntity(args) {
    const transaction = await this._getUpdateTransaction(args);
    return this.sanelyExecuteAndGetStatus(transaction);
  }
  _equals(what) {
    return false;
  }

  /**
   * Region of `executeSanely` overridable declarations. This should closely mimic the {@link ApiSession#execute} implementations.
   */

  /**
   * Actual `sanity-execution`-able implementation. There should be only one `this.session.execute` call per {@link LiveEntity}.
   */
  async executeSanely(what, returnType, getReceipt = false) {
    this.sanityCheck(what.constructor.name);
    return this.session.execute(what, returnType, getReceipt);
  }
  async sanelyExecuteAndGetStatus(transaction) {
    const receipt = await this.executeSanely(transaction, TypeOfExecutionReturn.Receipt, true);
    return receipt.status;
  }
  sanityCheck(opName = "") {
    if (!this.isSane) {
      throw new Error(`Cannot perform this${opName ? ` "${opName}"` : ""} operation on an entity which is no longer sane (is no longer live on the network)`);
    }
  }
}

class BaseLiveEntityWithBalance extends LiveEntity {
  async getBalanceOfLiveEntity() {
    const queryPayload = this._getBalancePayload();
    const balanceQuery = new AccountBalanceQuery(queryPayload);
    return this.executeSanely(balanceQuery, TypeOfExecutionReturn.Result, false);
  }
  transferHbarToLiveEntity(hbarAmount) {
    const amountToTransfer = hbarAmount instanceof Hbar ? hbarAmount : new Hbar(hbarAmount);
    const transferTransaction = new TransferTransaction().addHbarTransfer(this.session.wallet.account.id, amountToTransfer.negated()).addHbarTransfer(this.id.toString(), amountToTransfer);
    return this.sanelyExecuteAndGetStatus(transferTransaction);
  }
  associateTokensWithLiveEntity(tokens) {
    const tokenAssociateTransaction = new TokenAssociateTransaction().setAccountId(this.id.toString()).setTokenIds(tokens);
    return this.sanelyExecuteAndGetStatus(tokenAssociateTransaction);
  }
  async _getDeleteTransaction(args) {
    return this.newDeleteTransaction(this._getDeleteArguments(args));
  }
  _getDeleteArguments(args) {
    let argsToReturn = args;
    if (!args || !args.has("transferAccountId") || !args.has("transferContractId")) {
      argsToReturn = {
        ...args,
        transferAccountId: this.session.wallet.account.id
      };
    }
    return argsToReturn;
  }
}

class BasicCreatableEntity {
  constructor(name) {
    this.name = name;
  }
}

let KeyType;
(function (KeyType) {
  KeyType[KeyType["ECDSA"] = 0] = "ECDSA";
  KeyType[KeyType["ED25519"] = 1] = "ED25519";
  KeyType[KeyType["Unknown"] = 2] = "Unknown";
})(KeyType || (KeyType = {}));
class Account extends BasicCreatableEntity {
  static async mapAccountFeaturesToAccountArguments(session, features) {
    // we are looking to generate a key if a keyType exists on the AccountFeatures
    if (features.keyType !== null) {
      const key = await Account.considerGenerateKeyFromAccountFeatures(session.log, features);
      return Object.assign({}, features, {
        key
      });
    }
    return features;
  }

  /**
   * @param logger - StratoLogger to log information of the created key
   * @param features - AccountFeatures being used to find out what type of key needs to be generated
   * @returns - the key for the new account
   */
  static async considerGenerateKeyFromAccountFeatures(logger, features) {
    let keyToReturn = features.key;
    if (!features.key) {
      const {
        keyType
      } = features;
      const keyTypeString = keyType === KeyType.ED25519 ? KeyType[KeyType.ED25519] : KeyType[KeyType.ECDSA];
      keyToReturn = keyType === KeyType.ED25519 ? await PrivateKey.generateED25519Async() : await PrivateKey.generateECDSAAsync();
      logger.debug(`A new '${keyTypeString}' key has been created: ${keyToReturn.toStringDer()} . Copy it since this is only time you'll see it.`);
    }
    return keyToReturn;
  }
  constructor(info) {
    super("Account");
    this.accountFeatures = {
      keyType: KeyType.ED25519,
      ...info
    };
  }
  async createVia({
    session
  }) {
    let resolutedInfo;
    if (this.key) {
      resolutedInfo = Object.assign({}, this.accountFeatures, {
        key: this.key
      });
    }
    resolutedInfo = await Account.mapAccountFeaturesToAccountArguments(session, this.accountFeatures);
    const createAccountTransaction = new AccountCreateTransaction(resolutedInfo);
    const {
      accountId
    } = await session.execute(createAccountTransaction, TypeOfExecutionReturn.Receipt, true);
    return new LiveAccountWithPrivateKey({
      id: accountId,
      privateKey: resolutedInfo.key,
      session
    });
  }
}

class LiveAccount extends BaseLiveEntityWithBalance {
  constructor({
    session,
    id
  }) {
    super(session, id);
  }
  getSolidityAddress() {
    return this.id.toSolidityAddress();
  }
  getLiveEntityInfo() {
    const accountInfoQuery = new AccountInfoQuery().setAccountId(this.id);
    return this.executeSanely(accountInfoQuery, TypeOfExecutionReturn.Result, false);
  }
  newDeleteTransaction(args) {
    return new AccountDeleteTransaction({
      accountId: this.id,
      ...args
    });
  }
  async _getUpdateTransaction(args) {
    const propsUsedForUpdate = await Account.mapAccountFeaturesToAccountArguments(this.session, args);
    return new AccountUpdateTransaction(propsUsedForUpdate);
  }
  _getBalancePayload() {
    return {
      accountId: this.id
    };
  }
}

/**
 * A wrapper class that contains both a {@link LiveAccount} and its associated private-key generated, most likely, at network-creation time.
 * Consequently, this is meant to be generated when first {@link ApiSession.create}-ing an {@link Account}.
 */
class LiveAccountWithPrivateKey extends LiveAccount {
  constructor({
    session,
    id,
    privateKey
  }) {
    super({
      id,
      session
    });
    this.privateKey = privateKey;
  }
  async sign(transaction) {
    return transaction.sign(this.privateKey);
  }
  async _getUpdateTransaction(args) {
    const updateTransaction = await super._getUpdateTransaction(args);

    // TODO: freeze with signer before similar to the delete op?
    return this.sign(updateTransaction);
  }
  async _getDeleteTransaction(args) {
    let selfDeleteTransaction = await super._getDeleteTransaction(args);
    selfDeleteTransaction = await selfDeleteTransaction.freezeWithSigner(this.session.wallet.signer);
    return this.sign(selfDeleteTransaction);
  }
}

class StratoAddress {
  static getSolidityAddressMatchOrDieTryingFrom(addr) {
    const matchedSolidityAddress = extractSolidityAddressFrom(addr);
    if (!matchedSolidityAddress) {
      throw new Error(`The provided address '${addr}' does not appear to be a valid Solidity address.`);
    }
    // We're lower-casein this to match Hedera's ".toSolidityAddress" behavior for consistency
    return matchedSolidityAddress.toLowerCase();
  }
  constructor(session, address, shard = long.ZERO, realm = long.ZERO) {
    this.session = session;
    this.shard = shard;
    this.realm = realm;
    this.id = StratoAddress.getSolidityAddressMatchOrDieTryingFrom(address);
  }
  getSolidityAddress() {
    return this.id;
  }
  async toLiveAccount() {
    const id = AccountId.fromSolidityAddress(this.getSolidityAddress());
    return new LiveAccount({
      id,
      session: this.session
    });
  }
  async toLiveContract(cInterface) {
    const id = ContractId.fromEvmAddress(this.shard, this.realm, this.getSolidityAddress());
    return new LiveContract({
      cInterface,
      id,
      session: this.session
    });
  }
  equals(what) {
    if (what instanceof LiveEntity) {
      return what.id.toSolidityAddress() === this.id;
    }
    return typeof what === "string" ? extractSolidityAddressFrom(what).toLocaleLowerCase() === this.id : what instanceof AccountId ? what.toSolidityAddress() === this.id : false;
  }
}

function encodeToHex(what, addPrefix = true) {
  const unPrefixedHexEncoding = [...what].map(x => x.toString(16).padStart(2, "0")).join("");
  return addPrefix ? `0x${unPrefixedHexEncoding}` : unPrefixedHexEncoding;
} // Inspired from: https://gist.github.com/don/871170d88cf6b9007f7663fdbc23fe09

function decodeFromHex(hexString) {
  if (!hexString) {
    return new Uint8Array();
  } // remove the leading 0x


  hexString = hexString.replace(/^0x/, ""); // ensure even number of characters

  if (hexString.length % 2 != 0) {
    console.log("WARNING: expecting an even number of characters in the hexString");
  } // check for some non-hex characters


  const bad = hexString.match(/[G-Z\s]/i);

  if (bad) {
    console.log("WARNING: found non-hex characters", bad);
  } // split the string into pairs of octets


  const pairs = hexString.match(/[\dA-F]{2}/gi); // convert the octets to integers

  const integers = pairs.map(function (s) {
    return parseInt(s, 16);
  });
  return new Uint8Array(integers);
}

// This module holds generic functionality that belongs nowhere.
// Always be mindful when adding code here and try to refactor and group the functionality into something more meaningful.
// This project is not fond of utility classes.

/**
 * A generic mapper that transforms something to something else.
 * If what needs to be transformed is a plain, non-array, value, it just transforms it.
 * If it's an array, the transformation applies to all its elements.
 * If it's a deep nested array (array within an array), the transformation applies to the leaf elements.
 *
 * @param what The thing that will get transformed
 * @param into The transformer
 * @returns Transforms what into something else
 */
function transform(what, into) {
  return Array.isArray(what) ? what.map(el => transform(el, into)) : into(what);
}

/**
 * Safe, typed, way to use `Object.entries` to extract a vector of typed entries.
 *
 * @param obj The object to unpack
 * @returns An array of entries of type T the make up the object `obj`
 */
function typedObjectEntries(obj) {
  return Object.entries(!obj ? {} : obj);
}

class StratoContractArgumentsEncoder {
  constructor(abi) {
    this.abi = abi;
  }

  /**
   * Byte encodes `args` to the solidity expected format for the ABI's deployment function (aka constructor)
   */

  encode(args, forWhatFct) {
    const targetedFunction = forWhatFct !== undefined ? typeof forWhatFct === "string" ? this.abi.getFunction(forWhatFct) : forWhatFct : this.abi.deploy;
    if (!targetedFunction) {
      throw new Error(`There is no such '${forWhatFct}' function present in the targeted ABI`);
    }
    const fctInputs = targetedFunction.inputs;
    traverse$1(args).forEach(function (potentialArg) {
      const solArgDescription = this.path.reduce((state, propName) => {
        if (!isNaN(parseInt(propName))) {
          // property name is numeric
          if (state.baseType === "array") {
            // Bypass instance references
            return state;
          }
        } else {
          // property name is NOT numeric. It might be referencing a solidity struct prop
          if (state.type.startsWith("tuple")) {
            return state.components.find(component => component.name === propName);
          }
        }
        return state[propName];
      }, fctInputs);
      const requireBytesYetStringProvided = this.isLeaf && solArgDescription !== undefined && solArgDescription.type !== undefined && solArgDescription.type.startsWith("bytes") && typeof potentialArg === "string";

      // Do primitive leaf processing
      if (requireBytesYetStringProvided) {
        const considerMappingStringToUint8Array = arg => arg.startsWith("0x") ? arrayify(arg) : new TextEncoder().encode(arg);
        this.update(transform(potentialArg, considerMappingStringToUint8Array), true);
      }
      if (this.isLeaf || !(potentialArg instanceof Uint8Array) && !(potentialArg instanceof Hbar) && !isSolidityAddressable(potentialArg) && !BigNumber$1.isBigNumber(potentialArg) && !(potentialArg instanceof AccountId) && !(potentialArg instanceof ContractId) && !(potentialArg instanceof TokenId) && !(potentialArg instanceof TopicId)) {
        // We're only processing mostly leafs or higher objects of interest
        return;
      }
      if (solArgDescription.type.startsWith("address")) {
        const considerMappingSolidityAddressableToAddress = arg => isSolidityAddressable(arg) ? arg.getSolidityAddress() : arg instanceof AccountId ? arg.toSolidityAddress() : arg instanceof ContractId ? arg.toSolidityAddress() : arg instanceof TokenId ? arg.toSolidityAddress() : arg instanceof TopicId ? arg.toSolidityAddress() : arg;
        this.update(transform(potentialArg, considerMappingSolidityAddressableToAddress), true);
      } else if (potentialArg instanceof Hbar) {
        this.update(BigNumber.from(potentialArg.toTinybars().toString()), true);
      } else if (BigNumber$1.isBigNumber(potentialArg)) {
        this.update(BigNumber.from(potentialArg.toString()), true);
      }
    });
    const encodedFuncParams = forWhatFct !== undefined ? this.abi.encodeFunctionData(targetedFunction.name, args) : this.abi.encodeDeploy(args);
    return decodeFromHex(encodedFuncParams.slice(2));
  }
}

const UNHANDLED_EVENT_NAME = "UnhandledEventName";
function isContractQueryRequest(request) {
  return request instanceof ContractCallQuery;
}
function parseLogs(cInterface, logs) {
  return logs.map(recordLog => {
    const data = encodeToHex(recordLog.data);
    const topics = recordLog.topics.map(topic => encodeToHex(topic));
    try {
      const logDescription = cInterface.parseLog({
        data,
        topics
      });
      const decodedEventObject = Object.keys(logDescription.args).filter(evDataKey => isNaN(Number(evDataKey))).map(namedEvDataKey => ({
        [namedEvDataKey]: logDescription.args[namedEvDataKey]
      })).reduce((p, c) => ({
        ...p,
        ...c
      }), {});
      return {
        name: logDescription.name,
        payload: decodedEventObject
      };
    } catch (e) {
      // No-op, yet we need to filter this element out because something went wrong
      // TODO: log something here
      return null;
    }
  }).filter(parsedLogCandidate => parsedLogCandidate !== null);
}
class LiveContract extends BaseLiveEntityWithBalance {
  /**
   * Constructs a new LiveContract to be interacted with on the Hashgraph.
   */
  static async newFollowingUpload({
    session,
    contract,
    emitConstructorLogs,
    transaction
  }) {
    let id;
    let logs;
    if (emitConstructorLogs) {
      const createdContractRecord = await session.execute(transaction, TypeOfExecutionReturn.Record, true);
      id = createdContractRecord.receipt.contractId;
      logs = parseLogs(contract.interface, createdContractRecord.contractFunctionResult.logs);
    } else {
      const transactionReceipt = await session.execute(transaction, TypeOfExecutionReturn.Receipt, true);
      id = transactionReceipt.contractId;
      logs = [];
    }
    return new LiveContractWithLogs({
      cInterface: contract.interface,
      id,
      logs,
      session
    });
  }
  constructor({
    session,
    id,
    cInterface
  }) {
    super(session, id);
    this.events = new events.exports.EventEmitter();
    this.interface = cInterface;
    this.encoder = new StratoContractArgumentsEncoder(cInterface);

    // Dynamically inject ABI function handling
    Object.values(this.interface.functions).forEach(fDescription => Object.defineProperty(this, fDescription.name, {
      enumerable: true,
      value: async function (fDescription, ...args) {
        const {
          request,
          meta
        } = await this.createContractRequestFor({
          args,
          fDescription
        });
        const isNonQuery = !(request instanceof ContractCallQuery);
        const executionResultType = isNonQuery && meta.onlyReceipt ? TypeOfExecutionReturn.Receipt : TypeOfExecutionReturn.Result;
        const callResponse = await this.executeSanely(request, executionResultType, meta.emitReceipt);
        if (executionResultType == TypeOfExecutionReturn.Result) {
          this.tryToProcessForEvents(callResponse);
          return await this.tryExtractingResponse(callResponse, fDescription);
        }

        // Reaching this point means that only the receipt was requested. We have it so we pass it through
        return callResponse;
      }.bind(this, fDescription),
      writable: false
    }));
  }

  /**
   * Retrieves the Solidity address representation of the underlying, deployed, contract.
   */
  getSolidityAddress() {
    return this.id.toSolidityAddress();
  }

  /**
   * Registers/De-registers code to be executed when a particular contract event gets triggered.
   *
   * @param name - the name of the event of interest
   * @param clb - if {@link undefined}, it removes all registered callbacks for the provided event-name else,
   *              if a function callback is provided, registers it to be executed when the event gets fired
   * @throws - if there is no such event-name defined, an error gets thrown
   */
  onEvent(name, clb) {
    const eventExists = Object.values(this.interface.events).find(ev => ev.name === name) !== undefined;
    if (!eventExists && UNHANDLED_EVENT_NAME !== name) {
      throw new Error(`There is no such event named '${name}' defined in this contract.`);
    }
    if (!clb) {
      // remove all handlers for this event
      this.events.removeAllListeners(name);
    } else {
      // register the event handler
      this.events.on(name, clb);
    }
  }

  /**
   * Registers/De-registers code to be executed when a particular contract event gets triggered yet there are no event-handlers registered to handle it.
   *
   * @param clb - the callback to get executed, if defined, otherwise remove all callbacks for this special event
   */
  onUnhandledEvents(clb) {
    this.onEvent(UNHANDLED_EVENT_NAME, clb);
  }

  /**
   * Creates a contract query/call request based for the given function-description and the desired arguments (args).
   * The first argument is checked to see if it matches the constructor arguments schema and, if it does, it's used to construct the
   * actual request instance, discarding it in the process so that the remaining arguments can all be used as the actual values sent to
   * the targeted function.
   */
  async createContractRequestFor({
    fDescription,
    args
  }) {
    let requestOptionsPresentInArgs = false;
    const constructorArgs = {
      contractId: this.id,
      gas: this.session.defaults.contractTransactionGas
    };
    const meta = {
      emitReceipt: this.session.defaults.emitLiveContractReceipts,
      onlyReceipt: this.session.defaults.onlyReceiptsFromContractRequests
    };

    // Try to unpack common meta-args that can be passed in at query/transaction construction time
    if (args && args.length > 0) {
      if (args[0].gas instanceof Hbar) {
        args[0].gas = args[0].gas.toTinybars();
      }
      if (Number.isInteger(args[0].gas) || args[0].gas instanceof long) {
        constructorArgs.gas = args[0].gas;
        requestOptionsPresentInArgs = true;
      }
    }

    // Initialize the Hedera request-object itself passing in any additional constructor args (if provided)
    const request = fDescription.constant ? new ContractCallQuery(constructorArgs) : new ContractExecuteTransaction(constructorArgs);

    // Inject session-configurable defaults
    if (isContractQueryRequest(request) && this.session.defaults.paymentForContractQuery > 0) {
      const queryPaymentInHbar = Hbar.fromTinybars(this.session.defaults.paymentForContractQuery);
      request.setQueryPayment(queryPaymentInHbar);
    }

    // Try to inject setter-only options
    if (args && args.length > 0) {
      if (isContractQueryRequest(request)) {
        // Try setting additional Query properties
        if (args[0].maxQueryPayment instanceof Hbar) {
          request.setMaxQueryPayment(args[0].maxQueryPayment);
          requestOptionsPresentInArgs = true;
        }
        if (args[0].paymentTransactionId instanceof TransactionId) {
          request.setPaymentTransactionId(args[0].paymentTransactionId);
          requestOptionsPresentInArgs = true;
        }
        if (args[0].queryPayment instanceof Hbar) {
          request.setQueryPayment(args[0].queryPayment);
          requestOptionsPresentInArgs = true;
        }
      } else {
        // This is a state-changing Transaction. Try setting additional properties as well
        if (args[0].amount) {
          // number | string | Long | BigNumber | Hbar
          request.setPayableAmount(args[0].amount);
          requestOptionsPresentInArgs = true;
        }
        if (args[0].maxTransactionFee) {
          // number | string | Long | BigNumber | Hbar
          request.setMaxTransactionFee(args[0].maxTransactionFee);
          requestOptionsPresentInArgs = true;
        }
        if (Array.isArray(args[0].nodeAccountIds)) {
          request.setNodeAccountIds(args[0].nodeAccountIds);
          requestOptionsPresentInArgs = true;
        }
        if (args[0].transactionId instanceof TransactionId) {
          request.setTransactionId(args[0].transactionId);
          requestOptionsPresentInArgs = true;
        }
        if (args[0].transactionMemo) {
          // string
          request.setTransactionMemo(args[0].transactionMemo);
          requestOptionsPresentInArgs = true;
        }
        if (Number.isInteger(args[0].transactionValidDuration)) {
          request.setTransactionValidDuration(args[0].transactionValidDuration);
          requestOptionsPresentInArgs = true;
        }
      }
    }

    // Try extracting meta-arguments (if any)
    if (args && args.length > 0) {
      if (args[0].emitReceipt === false || args[0].emitReceipt === true) {
        meta.emitReceipt = args[0].emitReceipt;
        requestOptionsPresentInArgs = true;
      }
      if (args[0].onlyReceipt === false || args[0].onlyReceipt === true) {
        meta.onlyReceipt = args[0].onlyReceipt;
        requestOptionsPresentInArgs = true;
      }
    }

    // Try cleaning up arguments list if config object was provide
    if (requestOptionsPresentInArgs) {
      args = args.slice(1);
    }

    // Encode and bind function arguments
    request.setFunctionParameters(this.encoder.encode(args, fDescription));
    return {
      meta,
      request
    };
  }

  /**
   * Given a contract-request response (txResponse) and a targeted function-description, it tries to extract and prepare the caller response based on
   * the contract's output function ABI specs.
   */
  tryExtractingResponse(txResponse, fDescription) {
    let fResponse;
    const fResult = this.interface.decodeFunctionResult(fDescription, txResponse.asBytes());
    const fResultKeys = Object.keys(fResult).filter(evDataKey => isNaN(Number(evDataKey)));
    if (fDescription.outputs && fDescription.outputs.length !== 0) {
      if (fResultKeys.length === fDescription.outputs.length) {
        // A named object can be returned since all the outputs are named
        const isBytesTypeExpectedFor = propKey => fDescription.outputs.find(o => o.name === propKey).type.startsWith("bytes");
        const tryMappingToHederaBytes = propKey => isBytesTypeExpectedFor(propKey) ? arrayify(fResult[propKey]) : fResult[propKey];
        fResponse = fResultKeys.map(namedfDataKey => ({
          [namedfDataKey]: tryMappingToHederaBytes(namedfDataKey)
        })).reduce((p, c) => ({
          ...p,
          ...c
        }), {});
      } else {
        fResponse = [...fResult];

        // Map all Ethers HexString representations of bytes-type responses to their UInt8Array forms (same used by Hedera)
        fResponse = fDescription.outputs.map((dType, id) => dType.type.startsWith("bytes") ? arrayify(fResponse[id]) : fResponse[id]);

        // If there is only one result returned, we unpack it and return it as it is, ditching the hosting array
        if (fResponse.length === 1) {
          fResponse = fResponse[0];
        }
      }

      // Do various type re-mappings such as:
      //    - Ethers' BigNumber to the Hedera-used, bignumber.js equivalent
      //    - solidity-address compatible values to LiveAddress-es
      const tryRemapingValue = (what, f) => {
        let wasMapped = false;
        if (typeof what === "string" && extractSolidityAddressFrom(what) !== undefined) {
          // most likely, this is a solidity-address
          f(new StratoAddress(this.session, what, this.id.shard, this.id.realm), true);
          wasMapped = true;
        } else if (BigNumber.isBigNumber(what)) {
          f(new BigNumber$1(what.toString()), false);
          wasMapped = true;
        }
        return wasMapped;
      };
      if (!tryRemapingValue(fResponse, newVal => {
        fResponse = newVal;
      })) {
        traverse$1(fResponse).forEach(function (x) {
          tryRemapingValue(x, this.update);
        });
      }
    }
    return fResponse;
  }

  /**
   * Given the call-response of a contract-method call/query, we try to see if there have been any events emitted and, if so, we re-emit them on the live-contract events pub-sub channel.
   *
   * Note: even if there is an event triggered, if there are no handlers registered, the first thing we do is try to dump it on the {@link UNHANDLED_EVENT_NAME} channel.
   *       if there are no handlers registered there either, we skip the event all-together.
   */
  tryToProcessForEvents(callResponse) {
    const loggedEvents = parseLogs(this.interface, callResponse.logs);
    loggedEvents.forEach(({
      name,
      payload
    }) => {
      let evNameToSendTo;
      if (this.events.listenerCount(name) === 0) {
        // No one is interested in this event
        // Try to dump it to the "catch-all-if-none-defined" event handler
        if (this.events.listenerCount(UNHANDLED_EVENT_NAME) === 0) {
          // No default, catch-all event handler defined. Skip event entirely
          return;
        }
        evNameToSendTo = UNHANDLED_EVENT_NAME;
      } else {
        // We have listeners for this event. Business as usual
        evNameToSendTo = name;
      }
      try {
        this.events.emit(evNameToSendTo, payload);
      } catch (e) {
        if ('development' === "test") {
          // We re-interpret and throw it so that any tests running will be aware of it
          throw new Error(`The event-emitter handle '${name}' failed to execute with the following reason: ${e.message}`);
        }
        // otherwise, it's a No-op
      }
    });
  }

  getLiveEntityInfo() {
    const contractInfoQuery = new ContractInfoQuery().setContractId(this.id);
    return this.executeSanely(contractInfoQuery, TypeOfExecutionReturn.Result, false);
  }
  newDeleteTransaction(args) {
    return new ContractDeleteTransaction({
      contractId: this.id,
      ...args
    });
  }
  _getUpdateTransaction(args) {
    throw new Error("Method not implemented.");
  }
  _getBalancePayload() {
    return {
      contractId: this.id
    };
  }
}

/**
 * A wrapper class that contains both a {@link LiveContract} and its associated logs generated at construction time.
 * Consequently, this is meant to be generated when first {@link ApiSession.upload}-ing a {@link Contract}.
 */
class LiveContractWithLogs extends LiveContract {
  constructor({
    session,
    id,
    cInterface,
    logs
  }) {
    super({
      cInterface,
      id,
      session
    });
    this.liveContract = this;
    this.logs = logs;
  }
}

function config() {
  return {
    parsed: undefined
  };
}

class EnvironmentInvalidError extends Error {
  constructor(message) {
    super(message);
  }
}

/**
 * The Hedera Network label value used in library configurations (such as the {@link ApiSession.default} method) to signify
 * that the library is targeting a custom network implementation with its own nodes apart from [the official ones](https://docs.hedera.com/guides/mirrornet/hedera-mirror-node#mainnet).
 *
 * `Note:` When this type of network is selected, its node address book must also be provided and that is usually done through something like the
 *         `HEDERAS_NODES` env-parameter (when using {@link ApiSession.default})
 *
 * Example of a `.env` file that targets a `customnet`, [local hedera-services](https://github.com/buidler-labs/dockerized-hedera-services) deployment:
 * ```
 * HEDERAS_NETWORK=customnet
 * HEDERAS_NODES=127.0.0.1:50211#3
 * ```
 *
 * `Note #2:` If you're planning to target a local `customnet` deployment, you might as well add the operator credentials to the mix:
 * ```
 * HEDERAS_OPERATOR_ID=0.0.2
 * HEDERAS_OPERATOR_KEY=91132178e72057a1d7528025956fe39b0b847f200ab59b2fdd367017f3087137
 * ```
 * Please see our [dockerized-hedera-services](https://github.com/buidler-labs/dockerized-hedera-services) for more info as to how to run a local, [dockerized](https://hub.docker.com/r/buidlerlabs/hedera-services),
 * [hedera-services](https://github.com/hashgraph/hedera-services) network.
 */
const HEDERA_CUSTOM_NET_NAME = "customnet";
const AVAILABLE_NETWORK_NAMES = {
  CustomNet: HEDERA_CUSTOM_NET_NAME,
  MainNet: "mainnet",
  PreviewNet: "previewnet",
  TestNet: "testnet"
};
/**
 * The main entry-class for the Hedera Venin library.
 *
 * It starts out by referencing a Hedera Network (being it [official](https://docs.hedera.com/guides/mirrornet/hedera-mirror-node#mainnet) or {@link HEDERA_CUSTOM_NET_NAME | custom})
 * client before allowing to generate an {@link ApiSession} through the {@link HederaNetwork.login} method call.
 */
class HederaNetwork {
  static newFrom(params) {
    return new HederaNetwork(params.defaults, params.name, params.nodes);
  }
  constructor(defaults, name, nodesInfo) {
    this.defaults = defaults;
    this.name = name;
    this.nodesInfo = nodesInfo;
    if (typeof nodesInfo === "string") {
      this.nodes = this.parseNetworkAddressBookFrom(nodesInfo);
    } else {
      this.nodes = nodesInfo;
    }
    const acceptedNetworkNames = Object.values(AVAILABLE_NETWORK_NAMES);
    if (!acceptedNetworkNames.includes(this.name)) {
      throw new EnvironmentInvalidError(`There is no such '${this.name}' network available. In order to continue, please choose a valid name from: ${acceptedNetworkNames.join(", ")}`);
    }
    try {
      Client.forName(this.name);
    } catch (e) {
      // This is a non-standard client. Maybe it's a local-net one?
      if (HEDERA_CUSTOM_NET_NAME === this.name) {
        if (!this.nodes || Object.keys(this.nodes).length === 0) {
          throw new EnvironmentInvalidError(`Please provide a list of network nodes in order to use a ${this.name} network.`);
        }
      } else {
        // Note: this should never happen, but still ... better play it safe
        throw new EnvironmentInvalidError(`There is no such ${this.name} network available in this library. Available network names to choose from are: ${acceptedNetworkNames.join(", ")}`);
      }
    }
  }
  getClient() {
    if (HEDERA_CUSTOM_NET_NAME === this.name) {
      return Client.forNetwork(this.nodes);
    }
    return Client.forName(this.name);
  }

  /**
   * Parses the provided string and constructs the hedera-network nodes object required to initialize a custom Hedera Client.
   * The expected {@param string} format is in the following form: <ip>:<port>#<account-id>[,<ip2>:<port2>#<account-id2>...]
   * Example: 127.0.0.1:50211#2,127.0.0.1:50212:#5 would get mapped to the following object:
   * {
   *   "127.0.0.1:50211": new AccountId(2),
   *   "127.0.0.1:50212": new AccountId(5)
   * }
   */
  parseNetworkAddressBookFrom(val) {
    const networkInfo = {};
    if (val) {
      const nodeEntries = val.split(/\s*,\s*/);
      const nodeDefinitions = nodeEntries.map(entry => {
        if (entry.indexOf("#") === -1) {
          throw new EnvironmentInvalidError(`Node definition entry '${entry}' is missing the account-id separator (#)`);
        }
        const [address, rawAccountNr] = entry.split("#");
        const accountNr = parseInt(rawAccountNr);
        return {
          [address]: new AccountId(accountNr)
        };
      });
      for (const rnEntry of nodeDefinitions) {
        const nodeAddress = Object.keys(rnEntry)[0];
        networkInfo[nodeAddress] = rnEntry[nodeAddress];
      }
    }
    return networkInfo;
  }
}

/* eslint-disable @typescript-eslint/no-unused-vars */

class WalletProvider {
  constructor(ctx) {
    this.ctx = ctx;
    this.setNetwork(ctx.network);
  }
  setNetwork(network) {
    this.network = network;
    return this;
  }
  buildFor(data) {
    this.sanityCheck();
    return this._buildCold(data);
  }
  sanityCheck() {
    if (!this.network) {
      throw new Error("Please first provide a HederaNetwork to the WalletProvider in order to build a new Wallet.");
    }
  }
}
class NotSupportedWalletProvider extends WalletProvider {
  constructor(ctx, controller) {
    super(ctx);
    throw new Error("You're trying to create a wallet-provider for a not-supported wallet-type. Something went wrong since you most likely would not want to ever do that.");
  }
  _buildCold(data) {
    // No-op
    return Promise.resolve();
  }
}

class BasicStratoWallet {
  constructor(wallet) {
    this.wallet = wallet;
    this.signer = wallet;
  }

  /**
   * @override
   */
  get account() {
    return {
      id: this.wallet.getAccountId(),
      publicKey: this.wallet.getAccountKey()
    };
  }
  async execute(transaction) {
    let transactionToExecute;

    // Note: don't know if this is generic enough. Are web-browsers ok with this?
    if (transaction instanceof Transaction) {
      // We freeze only if it's not already frozen otherwise we lose all existing signatures
      if (!transaction.isFrozen()) {
        transactionToExecute = await transaction.freezeWithSigner(this.wallet);
      } else {
        transactionToExecute = transaction;
      }
      transactionToExecute = await transactionToExecute.signWithSigner(this.wallet);
    } else {
      transactionToExecute = transaction;
    }
    const transactionResponse = await transactionToExecute.executeWithSigner(this.wallet);
    return transactionResponse;
  }
  getReceipt(response) {
    return this.wallet.getProvider().getTransactionReceipt(response.transactionId);
  }
}

class BrowserWalletProvider extends WalletProvider {
  constructor(ctx, controller) {
    super(ctx);
    this.controller = controller;
  }
  async _buildCold(data) {
    return new BrowserWallet(this.controller, data.propName);
  }
}
class BrowserWallet extends BasicStratoWallet {
  constructor(controller, windowPropName) {
    super(window[windowPropName]);

    // TODO: bind to controller events somehow?
  }
}

class CredentialsInvalidError extends Error {
  constructor(message) {
    super(message);
  }
}

class LocalProvider {
  constructor(network) {
    this.client = network.getClient();
  }
  getLedgerId() {
    return this.client.ledgerId;
  }
  getNetwork() {
    return this.client.network;
  }
  getMirrorNetwork() {
    return this.client.mirrorNetwork;
  }
  getAccountBalance(accountId) {
    return new AccountBalanceQuery().setAccountId(accountId).execute(this.client);
  }
  getAccountInfo(accountId) {
    return new AccountInfoQuery().setAccountId(accountId).execute(this.client);
  }
  getAccountRecords(accountId) {
    return new AccountRecordsQuery().setAccountId(accountId).execute(this.client);
  }
  getTransactionReceipt(transactionId) {
    return new TransactionReceiptQuery().setTransactionId(transactionId).execute(this.client);
  }
  waitForReceipt(response) {
    return new TransactionReceiptQuery().setNodeAccountIds([response.nodeId]).setTransactionId(response.transactionId).execute(this.client);
  }
  call(request) {
    return request.execute(this.client);
  }
}

class HederaLocalWalletProvider extends WalletProvider {
  constructor(ctx, controller) {
    super(ctx);
    this.controller = controller;
  }
  async buildOperatedBy(operatorId, operatorKey) {
    this.sanityCheck();
    return new SdkWallet(this.controller, this.ctx.network, typeof operatorId === "string" ? AccountId.fromString(operatorId) : operatorId, typeof operatorKey === "string" ? PrivateKey.fromString(operatorKey) : operatorKey);
  }
  async _buildCold(data) {
    return this.buildOperatedBy(data.accountId, data.privateKey);
  }
}
class SdkWallet extends BasicStratoWallet {
  constructor(controller, network, operatorId, operatorKey) {
    super(new Wallet(operatorId, operatorKey, new LocalProvider(network)));

    // Bind to controller events
    this.network = network;
    this.operatorId = operatorId;
    this.operatorKey = operatorKey;
    controller.onAccountChanged(account => {
      this.operatorKey = PrivateKey.fromString(account.operatorKey);
      this.wallet = new Wallet(AccountId.fromString(account.operatorId), PrivateKey.fromString(account.operatorKey), new LocalProvider(network));
      this.operatorId = this.wallet.getAccountId();
    });
    controller.onNetworkChanged(network => {
      this.network = network;
      this.wallet = new Wallet(this.wallet.getAccountId(), operatorKey, new LocalProvider(network));
    });
  }
}

class Subscription {
  constructor(events, eventName, clb) {
    this.events = events;
    this.eventName = eventName;
    this.clb = clb;
    events.on(eventName, clb);
  }
  unsubscribe() {
    this.events.off(this.eventName, this.clb);
  }
}
class _NeverFiringSubscription extends Subscription {
  constructor() {
    super(new events.exports.EventEmitter(), "NeverFiringSubscription", _data => {
      /* No-op */
    });
  }
}
const NeverFiringSubscription = new _NeverFiringSubscription();

class BasicWalletController {
  static NETWORK_CHANGE_REQUESTED = "NETWORK_CHANGE_REQUESTED";
  static ACCOUNT_CHANGE_REQUESTED = "ACCOUNT_CHANGE_REQUESTED";
  constructor(ctx) {
    this.ctx = ctx;
    this.pubSub = new events.exports.EventEmitter();
  }
  changeAccount(account, ...args) {
    const accountPayload = this.getAccountPayload(account, ...args);
    this.pubSub.emit(BasicWalletController.ACCOUNT_CHANGE_REQUESTED, accountPayload);
  }
  changeNetwork(network) {
    this.pubSub.emit(BasicWalletController.NETWORK_CHANGE_REQUESTED, network);
  }
  onAccountChanged(clb) {
    return new Subscription(this.pubSub, BasicWalletController.ACCOUNT_CHANGE_REQUESTED, clb);
  }
  onNetworkChanged(clb) {
    return new Subscription(this.pubSub, BasicWalletController.NETWORK_CHANGE_REQUESTED, clb);
  }
}

class HederaWalletController extends BasicWalletController {
  constructor(ctx) {
    super(ctx);
  }
  getAccountPayload(account, ...args) {
    if (args.length === 0) {
      throw new Error("The private-key must also be provided in order to switch the account.");
    }
    try {
      const privateKey = args[0] instanceof PrivateKey ? args[0] : PrivateKey.fromString(args[0]);
      return {
        operatorId: account instanceof AccountId ? account.toString() : account,
        operatorKey: privateKey.toStringDer()
      };
    } catch (e) {
      throw new Error(`The provided key is not in a valid format. Cannot change account.`);
    }
  }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
class ImpotentWalletController {
  changeAccount(_account, ..._args) {
    throw new Error("This WalletController cannot change the account of the underlying wallet.");
  }
  changeNetwork(_network) {
    throw new Error("This WalletController cannot change the network of the underlying wallet.");
  }
  onAccountChanged(clb) {
    return NeverFiringSubscription;
  }
  onNetworkChanged(clb) {
    return NeverFiringSubscription;
  }
}

const WALLET_TYPE_CONSTRUCTOR_GUARD = {};
class WalletType {
  constructor(constructorGuard, name, defaultController = ImpotentWalletController, providerHaving = NotSupportedWalletProvider, computeColdStartOptionsFrom) {
    this.name = name;
    this.defaultController = defaultController;
    this.providerHaving = providerHaving;
    this.computeColdStartOptionsFrom = computeColdStartOptionsFrom;
    if (constructorGuard !== WALLET_TYPE_CONSTRUCTOR_GUARD) {
      throw new Error("Wallet types cannot be defined from outside this module!");
    }
  }
  equals(other) {
    return other instanceof WalletType && this.name === other.name;
  }
}
class WalletTypes {
  unknownWalletType = new WalletType(WALLET_TYPE_CONSTRUCTOR_GUARD, "Unknown");
  constructor() {
    this.knownWalletTypes = [new WalletType(WALLET_TYPE_CONSTRUCTOR_GUARD, "Sdk", HederaWalletController,
    // Default WalletController
    HederaLocalWalletProvider,
    // Associated WalletProvider
    params => {
      // ColdStart options parser for pre-configured runtime parameters
      try {
        return {
          accountId: AccountId.fromString(params.wallet.sdk.operatorId),
          privateKey: PrivateKey.fromString(params.wallet.sdk.operatorKey)
        };
      } catch (e) {
        throw new CredentialsInvalidError(e.message);
      }
    }), new WalletType(WALLET_TYPE_CONSTRUCTOR_GUARD, "Browser", ImpotentWalletController,
    // No WalletController
    BrowserWalletProvider,
    // Associated WalletProvider
    params => {
      // ColdStart options parser for pre-configured runtime parameters
      return {
        propName: params.wallet.window.propName
      };
    })];
  }
  isKnown(walletType) {
    return !this.Unknown.equals(walletType);
  }
  get Unknown() {
    return this.unknownWalletType;
  }
  getBy({
    name
  }) {
    const candidateWalletTypes = this.knownWalletTypes.filter(type => type.name === name);
    return candidateWalletTypes.length === 0 ? this.Unknown : candidateWalletTypes[0];
  }
}

/* eslint-env browser */
const LEVELS = {
  error: 0,
  warn: 1,
  // eslint-disable-next-line sort-keys
  info: 2,
  // eslint-disable-next-line sort-keys
  http: 3,
  verbose: 4,
  // eslint-disable-next-line sort-keys
  debug: 5,
  silly: 6
};
class StratoLogger extends EventEmitter$1 {
  constructor(params) {
    super();
    this.level = LEVELS[params.level];
    this.isLoggingEnabled = params.enabled;
  }

  get isSillyLoggingEnabled() {
    return this._isLevelEnabled(LEVELS.silly);
  }

  debug(message, ...meta) {
    if (this._isLevelEnabled(LEVELS.debug)) this.emit("debug", message, ...meta);
    return this;
  }

  error(message, ...meta) {
    if (this._isLevelEnabled(LEVELS.error)) this.emit("error", message, ...meta);
    return this;
  }

  info(message, ...meta) {
    if (this._isLevelEnabled(LEVELS.info)) this.emit("info", message, ...meta);
    return this;
  }

  silly(message, ...meta) {
    if (this._isLevelEnabled(LEVELS.silly)) this.emit("debug", message, ...meta);
    return this;
  }

  verbose(message, ...meta) {
    if (this._isLevelEnabled(LEVELS.verbose)) this.emit("debug", message, ...meta);
    return this;
  }

  warn(message, ...meta) {
    if (this._isLevelEnabled(LEVELS.warn)) this.emit("warn", message, ...meta);
    return this;
  }

  _isLevelEnabled(level) {
    return this.isLoggingEnabled && this.level >= level;
  }

}

class DefaultPrivateKeyWalletController extends HederaWalletController {
  constructor(ctx) {
    super(ctx);
  }
  getAccountPayload(account) {
    return super.getAccountPayload(account, this.ctx.params.wallet.controller.default.operatorKey);
  }
}

class WalletControllers {
  constructor(ctx) {
    this.impotentController = new ImpotentWalletController();
    this.knownControllers = [{
      name: "Hedera",
      value: new HederaWalletController(ctx)
    }, {
      name: "DefaultPrivateKey",
      value: new DefaultPrivateKeyWalletController(ctx)
    }];
  }
  get Unknown() {
    return this.impotentController;
  }
  getBy({
    name
  }) {
    const candidateWalletControllers = this.knownControllers.filter(controller => controller.name === name);
    return candidateWalletControllers.length === 0 ? this.Unknown : candidateWalletControllers[0].value;
  }
}

// Note: This follows the @hashgraph/sdk/lib/transaction/Transaction > CHUNK_SIZE value
//       v2.17.1 increased the size to 4096
const DEFAULT_FILE_CHUNK_SIZE = 4096;
const DefinedNetworkDefaults = {
  [AVAILABLE_NETWORK_NAMES.CustomNet]: {
    fileChunkSize: DEFAULT_FILE_CHUNK_SIZE
  },
  [AVAILABLE_NETWORK_NAMES.MainNet]: {
    fileChunkSize: DEFAULT_FILE_CHUNK_SIZE
  },
  [AVAILABLE_NETWORK_NAMES.TestNet]: {
    fileChunkSize: DEFAULT_FILE_CHUNK_SIZE
  },
  [AVAILABLE_NETWORK_NAMES.PreviewNet]: {
    fileChunkSize: DEFAULT_FILE_CHUNK_SIZE
  }
};

/**
 * Contains any parameters/objects that can be created with those parameters which are unpacked by other components in the library
 */
class StratoContext {
  constructor(source) {
    let dEnv = config({
      path: source.path
    }).parsed;
    const eParams = {};
    const rParams = source?.params ?? {};

    // Filter and get a hold of the raw parameters of interest
    if (!dEnv) {
      // Default to whatever lies in the {"HEDERAS_DEFAULT_EMIT_LIVE_CONTRACT_RECEIPTS":"true","HEDERAS_NETWORK":"testnet","HEDERAS_CONTRACTS_INCLUDED_PREFIXES":"inos,idos,staking,stakepools","HEDERAS_CONTRACTS_RELATIVE_PATH":"../contracts/contracts"}
      dEnv = {"HEDERAS_DEFAULT_EMIT_LIVE_CONTRACT_RECEIPTS":"true","HEDERAS_NETWORK":"testnet","HEDERAS_CONTRACTS_INCLUDED_PREFIXES":"inos,idos,staking,stakepools","HEDERAS_CONTRACTS_RELATIVE_PATH":"../contracts/contracts"};
    }
    Object.keys(dEnv).filter(rrParamKey => rrParamKey.startsWith("HEDERAS_")).forEach(acceptedParamKey => {
      eParams[acceptedParamKey] = dEnv[acceptedParamKey];
    });

    // Parse and extract the managed values
    const networkName = rParams.network?.name ?? eParams.HEDERAS_NETWORK ?? "unspecified";
    this.walletTypes = new WalletTypes();
    this.params = {
      logger: {
        enabled: (rParams.logger?.enabled ?? eParams.HEDERAS_LOGGER_ENABLED ?? "false") === "true",
        level: rParams.logger?.level ?? eParams.HEDERAS_LOGGER_LEVEL ?? "info"
      },
      network: {
        defaults: DefinedNetworkDefaults[rParams.network?.name ?? eParams.HEDERAS_NETWORK ?? "unspecified"],
        name: networkName,
        nodes: rParams.network?.nodes ?? eParams.HEDERAS_NODES ?? ""
      },
      session: {
        defaults: this.parseSessionDefaultsFrom(networkName, rParams, eParams)
      },
      wallet: this.computeWalletSpecsFrom(rParams, eParams)
    };
    this.walletControllers = new WalletControllers(this);
    this.log = new StratoLogger(this.params.logger);
    this.network = HederaNetwork.newFrom(this.params.network);
  }
  async getWallet(controller) {
    const walletType = typeof this.params.wallet.type === "string" ? this.walletTypes.getBy({
      name: this.params.wallet.type
    }) : this.params.wallet.type;
    const resolvedController = controller ?? this.walletControllers.getBy({
      name: this.params.wallet.controller.type
    }) ?? new walletType.defaultController(this);
    const provider = new walletType.providerHaving(this, resolvedController);
    const coldStartData = walletType.computeColdStartOptionsFrom(this.params);
    if (coldStartData) {
      return {
        controller: resolvedController,
        wallet: await provider.buildFor(coldStartData)
      };
    } else {
      throw new Error("Please provide either the cold-start data or a saved-state from where to create the bounded underlying Wallet with.");
    }
  }
  computeWalletSpecsFrom(rParams, eParams) {
    const walletControllerDefaultPrivateKey = rParams.wallet?.controller?.default?.operatorKey ?? eParams.HEDERAS_WALLET_CONTROLLER_DEFAULT_PRIVATE_KEY;
    const walletControllerType = rParams.wallet?.controller?.type ?? eParams.HEDERAS_WALLET_CONTROLLER ?? "Hedera";
    const walletType = this.walletTypes.getBy({
      name: typeof rParams.wallet?.type === "string" ? rParams.wallet?.type : eParams.HEDERAS_WALLET_TYPE ? eParams.HEDERAS_WALLET_TYPE : "Sdk"
    });
    const walletWindowPropName = rParams.wallet?.window?.propName ?? eParams.HEDERAS_WALLET_WINDOW_PROPERTY_NAME ?? "hedera";
    if (!this.walletTypes.isKnown(walletType)) {
      throw new Error("Only 'Sdk' and 'Browser' wallet types are currently supported. If not specified, it defaults to 'Sdk'.");
    }
    return {
      controller: {
        default: {
          operatorKey: walletControllerDefaultPrivateKey
        },
        type: walletControllerType
      },
      sdk: {
        operatorId: rParams.wallet?.sdk?.operatorId ?? eParams.HEDERAS_OPERATOR_ID,
        operatorKey: rParams.wallet?.sdk?.operatorKey ?? eParams.HEDERAS_OPERATOR_KEY
      },
      type: walletType,
      window: {
        propName: walletWindowPropName
      }
    };
  }
  parseSessionDefaultsFrom(networkName, rParams, eParams) {
    const resolveSessionDefaultValueFor = particle => eParams[`HEDERAS_${networkName.toUpperCase()}_DEFAULT_${particle.toUpperCase()}`] || eParams[`HEDERAS_DEFAULT_${particle.toUpperCase()}`];
    return {
      contractCreationGas: rParams.session?.defaults?.contractCreationGas ?? parseInt(resolveSessionDefaultValueFor("contract_creation_gas") ?? "150000"),
      contractTransactionGas: rParams.session?.defaults?.contractTransactionGas ?? parseInt(resolveSessionDefaultValueFor("contract_transaction_gas") ?? "169000"),
      emitConstructorLogs: rParams.session?.defaults?.emitConstructorLogs ?? (resolveSessionDefaultValueFor("emit_constructor_logs") ?? "true") === "true",
      emitLiveContractReceipts: rParams.session?.defaults?.emitLiveContractReceipts ?? (resolveSessionDefaultValueFor("emit_live_contracts_receipts") ?? "false") === "true",
      onlyReceiptsFromContractRequests: rParams.session?.defaults?.onlyReceiptsFromContractRequests ?? (resolveSessionDefaultValueFor("contract_requests_return_only_receipts") ?? "true") === "true",
      paymentForContractQuery: rParams.session?.defaults?.paymentForContractQuery ?? parseInt(resolveSessionDefaultValueFor("payment_for_contract_query") ?? "20000000"),
      tokenCreateTransactionFee: rParams.session?.defaults?.tokenCreateTransactionFee ?? parseInt(resolveSessionDefaultValueFor("token_create_transaction_fee") ?? "5000000000")
    };
  }
}

class BasicUploadableEntity {
  constructor(nameOfUpload) {
    this.nameOfUpload = nameOfUpload;
  }

  /**
   * Uploads this Uploadable to the desired session passing in arguments if provided.
   *
   * @param {Array} args - A list of arguments to use and/or pass along. If the first object contains a '_file' property, it's assumed that its content contains
   *                       FileCreateTransaction constructor arguments and is embedded in the transaction being created. It then goes on to discard that initial
   *                       value before passing the remaining arguments along to the _onFileUploaded implementation.
   * @public
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async uploadTo({
    session,
    args = []
  }) {
    const whatToUpload = await this.getContent();
    const {
      appendTxCount,
      areOverridesProvided,
      fileTransactions
    } = await this._getFileTransactionsFor({
      args,
      content: whatToUpload,
      session
    });
    const transactionReceipt = await session.execute(fileTransactions[0], TypeOfExecutionReturn.Receipt, true);
    if (transactionReceipt.status !== Status.Success) {
      throw new Error(`There was an issue while creating the file (status ${transactionReceipt.status}). Aborting file upload.`);
    } else {
      session.log.debug(`Uploaded content to HFS resulting in file id ${transactionReceipt.fileId}`);
      if (fileTransactions.length > 1 && fileTransactions[1] instanceof FileAppendTransaction) {
        session.log.debug(`Appending the remaining content with a total of ${appendTxCount} file-append transactions.`);
        await session.execute(fileTransactions[1].setFileId(transactionReceipt.fileId), TypeOfExecutionReturn.Result, true);
        session.log.verbose(`Done appending. Content has been successfully uploaded and is available at HFS id ${transactionReceipt.fileId}`);
      }
    }
    if (areOverridesProvided) {
      args = args.slice(1);
    }
    return this.onFileUploaded({
      args,
      receipt: transactionReceipt,
      session
    });
  }
  async _getFileTransactionsFor({
    content,
    session,
    args = []
  }) {
    const fileChunkSize = session.network.defaults.fileChunkSize;
    const fileTransactions = [];
    let fileCreationOverrides = {};

    // If available, lock onto any file-creation arguments to embedd when constructing the initial transaction
    if (args.length > 0 && Object.keys(args[0]).length !== 0 && Object.keys(args[0])[0] === "_file") {
      fileCreationOverrides = args[0]._file;
    }

    // Start off with a file-create transaction
    fileTransactions.push(new FileCreateTransaction(Object.assign({}, {
      keys: [session.wallet.account.publicKey],
      ...fileCreationOverrides
    }, {
      contents: content.length > fileChunkSize ? content.slice(0, fileChunkSize) : content
    })));

    // Add, if necessary, other file-append transactions to consume the rest of the chunks
    let maxChunks = 0;
    if (content.length > fileChunkSize) {
      const contentToAppend = content.slice(fileChunkSize);
      maxChunks = Math.ceil(contentToAppend.length / fileChunkSize);
      fileTransactions.push(new FileAppendTransaction({
        contents: contentToAppend,
        maxChunks
      }));
    }
    return {
      appendTxCount: maxChunks,
      areOverridesProvided: Object.keys(fileCreationOverrides).length !== 0,
      fileTransactions
    };
  }
}

class LiveFile extends LiveEntity {
  constructor({
    session,
    id,
    data
  }) {
    super(session, id instanceof FileId ? id : FileId.fromString(id));
    this.data = data;
  }
  getLiveEntityInfo() {
    const fileInfoQuery = new FileInfoQuery({
      fileId: this.id
    });
    return this.executeSanely(fileInfoQuery, TypeOfExecutionReturn.Result, false);
  }
  getSolidityAddress() {
    return this.id.toSolidityAddress();
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async _getDeleteTransaction(args) {
    return new FileDeleteTransaction({
      fileId: this.id
    });
  }
  async _getUpdateTransaction(args) {
    return new FileUpdateTransaction({
      ...args,
      fileId: this.id
    });
  }
  async getContents() {
    const fileContentsQuery = new FileContentsQuery({
      fileId: this.id
    });
    const queryResponse = await this.executeSanely(fileContentsQuery, TypeOfExecutionReturn.Result, false);
    return queryResponse;
  }
}

class File extends BasicUploadableEntity {
  constructor(info) {
    super("File");
    this.info = info;
  }
  async getContent() {
    return this.info;
  }
  async onFileUploaded({
    session,
    receipt,
    args = []
  }) {
    return new LiveFile({
      data: this.info,
      id: receipt.fileId,
      session
    });
  }
}

/**
 * Represents a Hedera, HFS-managed, Json object
 */
class LiveJson extends LiveFile {
  constructor({
    session,
    id,
    data
  }) {
    super({
      data,
      id,
      session
    });
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    // Dynamically bind 'data' properties to instance
    Object.keys(data).forEach(jDataKey => Object.defineProperty(this, jDataKey, {
      enumerable: true,
      value: data[jDataKey],
      writable: false
    }));
  }
}

/**
 * A data-holder class that can source the creation of a {@link LiveJson} persisted on the [Hedera File Service (HFS)](https://docs.hedera.com/guides/docs/sdks/file-storage)
 */
class Json extends BasicUploadableEntity {
  /**
   * Checks to see if a piece of data can be referenced by a {@link Json} object or not.
   *
   * @param {object} jInfo - info-param to check
   * @returns - true if the data is {@link Json} reference-able and false otherwise
   */
  static isInfoAcceptable(jInfo) {
    try {
      Json._guardForInvalid(jInfo);
      return true;
    } catch (e) {
      // No-op
    }
    return false;
  }
  static _guardForInvalid(jInfo) {
    if (jInfo === null || typeof jInfo !== "object") {
      throw new Error("Please provide a valid JSON object to instantiate a static Json with.");
    } else {
      const containsInvalidKeys = Object.keys(jInfo).find(jInfoKey => jInfoKey.length > 0 && (jInfoKey[0] === "_" || jInfoKey === "id")) !== undefined;
      if (containsInvalidKeys) {
        throw new Error("Static Jsons can only be constructed from JSON objects who's properties don't start with '_' or has the 'id' naming.");
      }
    }
  }

  /**
   * Tries to construct the a new {@link Json} instance that hosts the provided info. Throws an error if, for any reason, the provided data cannot be Json-referenced.
   *
   * @param info - the payload to reference
   */
  constructor(info) {
    super("Json");
    this.info = info;
    Json._guardForInvalid(info);
  }
  async getContent() {
    return JSON.stringify(this.info);
  }
  async onFileUploaded({
    session,
    receipt,
    args = []
  }) {
    return new LiveJson({
      data: JSON.stringify(this.info),
      id: receipt.fileId,
      session
    });
  }
}

let TypeOfExecutionReturn;
(function (TypeOfExecutionReturn) {
  TypeOfExecutionReturn["Receipt"] = "Receipt";
  TypeOfExecutionReturn["Record"] = "Record";
  TypeOfExecutionReturn["Result"] = "Result";
})(TypeOfExecutionReturn || (TypeOfExecutionReturn = {}));
const SESSION_CONSTRUCTOR_GUARD = {};

// The inner-name for the receipt pub-sub event slot
const TRANSACTION_ON_RECEIPT_EVENT_NAME = "__TransactionOnReceiptAvailable_EventName__";

/**
 * The core class used for all business-logic, runtime network-interactions.
 *
 * Should only be instantiable through direct {@link ApiSession} factory methods such as {@link ApiSession.default} (to load from a .env-like file/runtime {"HEDERAS_DEFAULT_EMIT_LIVE_CONTRACT_RECEIPTS":"true","HEDERAS_NETWORK":"testnet","HEDERAS_CONTRACTS_INCLUDED_PREFIXES":"inos,idos,staking,stakepools","HEDERAS_CONTRACTS_RELATIVE_PATH":"../contracts/contracts"})
 * or {@link ApiSession.buildFrom} to construct an {@link ApiSession} from a manually-built {@link StratoContext} instance.
 */
class ApiSession {
  /**
   * Builds and retrieves the default {@link ApiSession} associated with this runtime. There are currently 2 ways of providing the parameters required for the api-session to be built:
   * - either pass them through the {@param source.env} parameter property (defaults to the `{"HEDERAS_DEFAULT_EMIT_LIVE_CONTRACT_RECEIPTS":"true","HEDERAS_NETWORK":"testnet","HEDERAS_CONTRACTS_INCLUDED_PREFIXES":"inos,idos,staking,stakepools","HEDERAS_CONTRACTS_RELATIVE_PATH":"../contracts/contracts"}` for node environments) or
   * - give the path to a [dotenv](https://www.npmjs.com/package/dotenv) like file (defaults to `.env`) from which they are loaded by the library (the {@link source.path} parameter)
   *   which can be auto-overwritten via the {@link undefined} value
   *
   * `Note:` At least one source must be properly wired and if both these parameter sources are set, the environment/runtime values overwrite the file-loaded ones.
   *
   * In order for the default {@link ApiSession} to be generated, the resulting resolved parameters must have the following values present:
   * - `HEDERAS_NETWORK` : the targeted hedera-network cluster. Can be one of the following: `mainnet`, `testnet`, `previewnet` or {@link HederaNetwork.HEDERA_CUSTOM_NET_NAME | customnet}
   * - `HEDERAS_NODES` : (mandatory if `HEDERAS_NETWORK={@link HederaNetwork.HEDERA_CUSTOM_NET_NAME}`) a comma separated list of {@link HederaNodesAddressBook} nodes encoded in
   *                     the following format `<node_ip>:<node_port>#<account_number>`. Eg. `127.0.0.1:502111#3` would be parsed in an address book having a node with IP `127.0.0.1`
   *                     and port 502111 associated with {@link AccountId} `3`
   * - `HEDERAS_WALLET_TYPE` : the network {@link StratoWallet} to use. Possible Values are statically defined in the {@link WalletTypes} props. If not provided, it defaults to `Sdk` which
   *                           targets the native {@link Wallet} provided by the Hedera SDK.
   *
   * For other possible config values, please either see the `.env.sample` info file provided with the main repo code or, better yet, the {@link https://hsj-docs.buidlerlabs.com/markdown/configuration online configuration} docs.
   */
  static async default(params = {}, path = undefined || ".env") {
    const ctxArgs = typeof params === "string" ? {
      params: {},
      path: params
    } : {
      params,
      path
    };
    const ctx = new StratoContext(ctxArgs);
    return ApiSession.buildFrom(ctx);
  }

  /**
   * Another, more parametrically, way to build an {@link ApiSession} besides the {@link ApiSession.default} variant.
   */
  static async buildFrom(ctx) {
    const {
      wallet,
      controller
    } = await ctx.getWallet();
    return {
      controller,
      session: new ApiSession(SESSION_CONSTRUCTOR_GUARD, {
        client: wallet,
        ctx
      })
    };
  }
  /**
   * @hidden
   */
  constructor(constructorGuard, {
    ctx,
    client
  }) {
    if (constructorGuard !== SESSION_CONSTRUCTOR_GUARD) {
      throw new Error("API sessions can only be constructed through a SessionBuilder instance!");
    }
    this.log = ctx.log;
    this.network = ctx.network;
    this.client = client;
    this.defaults = ctx.params.session.defaults;
    this.events = new events.exports.EventEmitter();
  }

  /**
   * Retrieves the wallet-info structure portraying both account and current signer info for this {@link ApiSession}.
   */
  get wallet() {
    return this.client;
  }

  /**
   * Creates a new {@link LiveEntity} such as an {@link LiveAccount} or a {@link LiveToken}.
   *
   * @param what {@link CreatableEntity} - the prototype of the entity of interest
   * @returns - an interactive {@link LiveEntity} instance which resides on the chain
   */
  async create(what) {
    this.log.info(`Creating a new Hedera ${what.name}`);
    const createdLiveEntity = await what.createVia({
      session: this
    });
    this.log.info(`Successfully created ${what.name} id ${createdLiveEntity.id}`);
    return createdLiveEntity;
  }

  /**
   * Queries/Executes a contract function, capable of returning the {@link ContractFunctionResult} if successful. This depends on the {@param returnType} of course.
   */

  // Overload implementation
  async execute(transaction, returnType, getReceipt = false) {
    const isContractTransaction = transaction instanceof ContractCallQuery || transaction instanceof ContractExecuteTransaction;
    let executionResult;
    let txReceipt;
    let txRecord;
    const txResponse = await this.client.execute(transaction);

    // start with the assumption that either the execution is not a contract-transaction or that the transaction-response is not a TransactionResponse
    executionResult = txResponse;

    // see if the above assumption holds and refine executionResult if case may be
    if (txResponse instanceof TransactionResponse) {
      // start out by generating the receipt for the original transaction
      txReceipt = await this.client.getReceipt(txResponse);
      if (returnType === TypeOfExecutionReturn.Record || isContractTransaction && returnType === TypeOfExecutionReturn.Result) {
        const txRecordQuery = new TransactionRecordQuery().setTransactionId(txResponse.transactionId);
        txRecord = await this.client.execute(txRecordQuery);

        // lock onto the contract-function-result of the record just in case a Result return-type is expected
        executionResult = txRecord.contractFunctionResult;
      }
      if (this.canReceiptBeEmitted(getReceipt)) {
        this.events.emit(TRANSACTION_ON_RECEIPT_EVENT_NAME, {
          receipt: txReceipt,
          transaction: transaction
        });
      }
    } else {
      // Note: ContractFunctionResult-s cannot emit receipts!
    }

    // Depending on the return-type resolution, fetch the typed-result
    return {
      [TypeOfExecutionReturn.Record]: txRecord,
      [TypeOfExecutionReturn.Receipt]: txReceipt,
      [TypeOfExecutionReturn.Result]: executionResult
    }[returnType];
  }

  /**
   * Retrieves the solidity-address of the underlying {@link AccountId} that's operating this session.
   */
  getSolidityAddress() {
    return this.wallet.account.id.toSolidityAddress();
  }

  /**
   * Loads a pre-deployed {@link LiveContract} ready to be called into at runtime. The contract-interface is passed in raw-ly
   * through the {@link abi} param.
   *
   * @param {object} options
   * @param {ContractId|string} options.id - the {@link ContractId} to load being it string-serialized or already parsed
   * @param {Promised<Interface>|Promised<Array>} options.abi - either the [etherjs contract interface](https://docs.ethers.io/v5/api/utils/abi/interface/) or
   *                                                            the [etherjs Interface compatible ABI definitions](https://docs.ethers.io/v5/api/utils/abi/interface/#Interface--creating)
   *                                                            to use with the resulting live-contract. Promises that resolve to any of these 2 types are also accepted.
   */
  async getLiveContract({
    id,
    abi = []
  }) {
    let targetedContractId;
    const resolutedAbi = await abi;
    try {
      targetedContractId = id instanceof ContractId ? id : ContractId.fromString(id);
    } catch (e) {
      throw new Error("Please provide a valid Hedera contract id in order try to lock onto an already-deployed contract.");
    }
    return new LiveContract({
      cInterface: resolutedAbi instanceof Interface ? resolutedAbi : new Interface(resolutedAbi),
      id: targetedContractId,
      session: this
    });
  }

  /**
   * Given a {@link FileId} (string-serialized or parsed) of a deployed {@link Json} instance, retrieves a {@link LiveJson} reference.
   *
   * @param {object} options
   * @param {FileId | string} options.id - the file-id to load parsed as a {@link FileId} or raw in a string-serialized
   */
  async getLiveJson({
    id
  }) {
    let targetedFileId;
    try {
      targetedFileId = id instanceof FileId ? id : FileId.fromString(id);
    } catch (e) {
      throw new Error("Please provide a valid Hedera file id in order try to lock onto an already-deployed Json object.");
    }
    const fileContentsQuery = new FileContentsQuery().setFileId(targetedFileId);
    const fileContentsBuffer = await this.execute(fileContentsQuery, TypeOfExecutionReturn.Result, false);
    const fileContents = new TextDecoder("utf8").decode(fileContentsBuffer);

    // TODO: use file Memo to store hash of file-contents and only return LiveJson instance if the 2 values match
    return new LiveJson({
      data: JSON.parse(fileContents),
      id: targetedFileId,
      session: this
    });
  }

  /**
   * Register a callback to be called when a receipt is required and available for a transaction.
   *
   * @param clb - Callback function to be called when a {@link TransactionedReceipt} is available. The `transactionedReceipt` contains
   *              a reference to both the actual transaction being executed and the resulting receipt.
   * @returns {ReceiptSubscription} - A subscription object that exposes a 'unsubscribe' method to cancel a subscription.
   */
  subscribeToReceiptsWith(clb) {
    return new Subscription(this.events, TRANSACTION_ON_RECEIPT_EVENT_NAME, clb);
  }

  /**
   * Given an {@link UploadableEntity}, it tries ot upload it using the currently configured {@link ApiSession} passing in-it any provided {@link args}.
   *
   * @param {Uploadable} what - The {@link UploadableEntity} to push through this {@link ApiSession}
   * @param {*} args - A list of arguments to pass through the upload operation itself.
   *                   Note: this list has, by convention, at various unpacking stages in the call hierarchy, the capabilities to specify SDK behavior through
   *                         eg. "_file" ({@link UploadableEntity}) or "_contract" ({@link Contract})
   * @returns - An instance of the {@link UploadableEntity} concrete result-type which is a subtype of {@link LiveEntity}.
   */

  // Overload implementation
  async upload(what, ...args) {
    let uploadableWhat;
    if (what instanceof BasicUploadableEntity === false) {
      if (typeof what === "string" || what instanceof Uint8Array) {
        uploadableWhat = new File(what);
      } else if (Json.isInfoAcceptable(what)) {
        uploadableWhat = new Json(what);
      } else {
        throw new Error("Can only upload UploadableFile-s or Json-file acceptable content.");
      }
    } else {
      // upload what was given as is since it's an UploadableEntity type already
      uploadableWhat = what;
    }
    this.log.info(`Uploading a new ${uploadableWhat.nameOfUpload} to Hedera File Service (HFS).`);
    const createdLiveEntity = await uploadableWhat.uploadTo({
      args,
      session: this
    });
    this.log.info(`Successfully created a ${uploadableWhat.nameOfUpload} id ${createdLiveEntity.id}.`);
    return createdLiveEntity;
  }
  canReceiptBeEmitted(isEmitReceiptRequested) {
    return isEmitReceiptRequested && this.events.listenerCount(TRANSACTION_ON_RECEIPT_EVENT_NAME) !== 0;
  }
}

const _GUARD_OBJ = {};
class TokenType {
  constructor(gObj, hTokenType) {
    this.hTokenType = hTokenType;
    if (gObj !== _GUARD_OBJ) {
      throw new Error("TokenType-s can only be created from within the static/Token module");
    }
  }
  equals(what) {
    return what instanceof TokenType ? this.hTokenType._code === what.hTokenType._code : what instanceof TokenType$1 ? this.hTokenType._code === what._code : false;
  }
}
const TokenTypes = {
  FungibleCommon: new TokenType(_GUARD_OBJ, TokenType$1.FungibleCommon),
  NonFungibleUnique: new TokenType(_GUARD_OBJ, TokenType$1.NonFungibleUnique)
};
class Token extends BasicCreatableEntity {
  static mapTokenFeaturesToTokenUpgradeArguments(tokenFeatures) {
    const upgradeFeatures = {};
    tokenFeatures.keys?.admin && (upgradeFeatures["adminKey"] = tokenFeatures.keys?.admin);
    tokenFeatures.keys?.feeSchedule && (upgradeFeatures["feeScheduleKey"] = tokenFeatures.keys?.feeSchedule);
    tokenFeatures.keys?.freeze && (upgradeFeatures["freezeKey"] = tokenFeatures.keys?.freeze);
    tokenFeatures.keys?.kyc && (upgradeFeatures["kycKey"] = tokenFeatures.keys?.kyc);
    tokenFeatures.keys?.pause && (upgradeFeatures["pauseKey"] = tokenFeatures.keys?.pause);
    tokenFeatures.keys?.supply && (upgradeFeatures["supplyKey"] = tokenFeatures.keys?.supply);
    tokenFeatures.keys?.wipe && (upgradeFeatures["wipeKey"] = tokenFeatures.keys?.wipe);
    tokenFeatures.name && (upgradeFeatures["tokenName"] = tokenFeatures.name);
    tokenFeatures.symbol && (upgradeFeatures["tokenSymbol"] = tokenFeatures.symbol);
    tokenFeatures.treasuryAccountId && (upgradeFeatures["treasuryAccountId"] = tokenFeatures.treasuryAccountId);
    return {
      ...upgradeFeatures,
      ...tokenFeatures
    };
  }
  static mapTokenFeaturesToTokenArguments(tokenFeatures, session) {
    const sessionPublicKey = session.wallet.account.publicKey;
    const sessionAccountId = session.wallet.account.id;
    return {
      // First map to expected properties
      adminKey: tokenFeatures.keys?.admin !== null ? tokenFeatures.keys?.admin ?? sessionPublicKey : undefined,
      feeScheduleKey: tokenFeatures.keys?.feeSchedule !== null ? tokenFeatures.keys?.feeSchedule ?? sessionPublicKey : undefined,
      freezeKey: tokenFeatures.keys?.freeze !== null ? tokenFeatures.keys?.freeze ?? sessionPublicKey : undefined,
      kycKey: tokenFeatures.keys?.kyc !== null ? tokenFeatures.keys?.kyc ?? sessionPublicKey : undefined,
      pauseKey: tokenFeatures.keys?.pause !== null ? tokenFeatures.keys?.pause ?? sessionPublicKey : undefined,
      supplyKey: tokenFeatures.keys?.supply !== null ? tokenFeatures.keys?.supply ?? sessionPublicKey : undefined,
      tokenName: tokenFeatures.name,
      tokenSymbol: tokenFeatures.symbol,
      tokenType: tokenFeatures.type.hTokenType ?? TokenType$1.FungibleCommon,
      treasuryAccountId: tokenFeatures.treasuryAccountId ?? sessionAccountId,
      wipeKey: tokenFeatures.keys?.wipe !== null ? tokenFeatures.keys?.wipe ?? sessionPublicKey : undefined,
      // Merge everything with what's provided
      ...tokenFeatures
    };
  }
  constructor(info) {
    super("Token");
    this.info = info;
  }
  async createVia({
    session
  }) {
    const constructorArgs = Token.mapTokenFeaturesToTokenArguments(this.info, session);
    const createTokenTransaction = new TokenCreateTransaction(constructorArgs);
    let transactionFee;
    if (this.info.maxTransactionFee) {
      transactionFee = this.info.maxTransactionFee instanceof Hbar ? this.info.maxTransactionFee : new Hbar(this.info.maxTransactionFee);
    } else if (session.defaults.tokenCreateTransactionFee > 0) {
      transactionFee = Hbar.fromTinybars(session.defaults.tokenCreateTransactionFee);
    }
    if (transactionFee) {
      createTokenTransaction.setMaxTransactionFee(transactionFee);
    }
    const creationReceipt = await session.execute(createTokenTransaction, TypeOfExecutionReturn.Receipt, true);
    return new LiveToken({
      id: creationReceipt.tokenId,
      session
    });
  }
}

/**
 * Represents a native Token on the Hedera Token Service
 */
class LiveToken extends LiveEntity {
  constructor({
    session,
    id
  }) {
    super(session, id);
  }
  getSolidityAddress() {
    return this.id.toSolidityAddress();
  }
  async assignSupplyControlTo(key) {
    const tokenUpdateTx = new TokenUpdateTransaction().setTokenId(this.id).setSupplyKey(key instanceof Key ? key : key.id);
    await this.executeSanely(tokenUpdateTx, TypeOfExecutionReturn.Receipt, true);
  }
  async getLiveEntityInfo() {
    const tokenInfoQuery = new TokenInfoQuery().setTokenId(this.id);
    return this.executeSanely(tokenInfoQuery, TypeOfExecutionReturn.Result, false);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async _getDeleteTransaction(args) {
    return new TokenDeleteTransaction({
      tokenId: this.id
    });
  }
  async _getUpdateTransaction(args) {
    const featuresUsedInTransaction = Token.mapTokenFeaturesToTokenUpgradeArguments(args);
    return new TokenUpdateTransaction({
      ...featuresUsedInTransaction,
      tokenId: this.id
    });
  }
}

class Topic extends BasicCreatableEntity {
  static mapTopicFeaturesToTopicArguments(topicFeatures) {
    return {
      adminKey: topicFeatures.keys?.admin,
      autoRenewAccountId: topicFeatures.autoRenewAccountId,
      autoRenewPeriod: topicFeatures.autoRenewPeriod,
      submitKey: topicFeatures.keys?.submit,
      topicMemo: topicFeatures.memo
    };
  }
  constructor(topicFeatures = {}) {
    super("Topic");
    this.topicFeatures = topicFeatures;
  }
  async createVia({
    session
  }) {
    const constructorArgs = Topic.mapTopicFeaturesToTopicArguments(this.topicFeatures);
    const createTopicTransaction = new TopicCreateTransaction(constructorArgs);
    const creationReceipt = await session.execute(createTopicTransaction, TypeOfExecutionReturn.Receipt, true);
    return new LiveTopic({
      session,
      topicId: creationReceipt.topicId
    });
  }
}

/**
 * Represents a Topic on the Hedera Consensus Service
 */
class LiveTopic extends LiveEntity {
  constructor({
    session,
    topicId
  }) {
    super(session, topicId instanceof TopicId ? topicId : TopicId.fromString(topicId));
  }
  getLiveEntityInfo() {
    const topicInfoQuery = new TopicInfoQuery({
      topicId: this.id
    });
    return this.executeSanely(topicInfoQuery, TypeOfExecutionReturn.Result, false);
  }
  getSolidityAddress() {
    return this.id.toSolidityAddress();
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async _getDeleteTransaction(args) {
    return new TopicDeleteTransaction({
      topicId: this.id
    });
  }
  async _getUpdateTransaction(args) {
    const featuresUsedInTransaction = Topic.mapTopicFeaturesToTopicArguments(args);
    return new TopicUpdateTransaction({
      ...featuresUsedInTransaction,
      topicId: this.id
    });
  }
  submitMessage(message) {
    const messageSubmitTransaction = new TopicMessageSubmitTransaction({
      message,
      topicId: this.id
    });
    return this.sanelyExecuteAndGetStatus(messageSubmitTransaction);
  }
}

/* eslint-disable no-undef */
const VIRTUAL_SOURCE_CONTRACT_FILE_NAME = "__contract__.sol";
class SolidityCompiler {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static compile({
    code,
    path
  }) {
    throw new Error("Compiling contracts is not available in this distribution. Please see the docs on how to enable it.");
  }

}

// An error-wrapper class around Solidity compiler issues
class CompileIssues extends Error {
  static tryThrowingIfErrorsIn({
    compileResult = null,
    ignoreWarnings = true
  }) {
    if (null != compileResult && Array.isArray(compileResult.errors)) {
      const issuesReported = compileResult.errors.filter(err => ignoreWarnings && err.type !== "Warning" || !ignoreWarnings);
      if (issuesReported.length != 0) {
        throw new CompileIssues(issuesReported);
      }
    }
  }
  static _listOfSimpleIssueMessagesFor(rawIssues) {
    return rawIssues.map(rIssue => `[ ${rIssue.sourceLocation.start}:${rIssue.sourceLocation.end} ] ${rIssue.formattedMessage}`);
  }

  /**
   * @private
   */
  constructor(issues) {
    super(`There are issues with the contract code:\n${CompileIssues._listOfSimpleIssueMessagesFor(issues).join("\n")}`);
    this.issues = issues;
  }
}

/**
 * Converts a higher-order library-address (eg. ContractId) into a lower-referenced solidity address ready for solc consumption
 *
 * @param libraries The object of libraries to go through and try to convert down
 * @returns A library-object of primitive addresses (solidity string addresses) associated to library names
 */
function mapToSolidityLibraries(libraries) {
  const solidityLibraries = {};
  for (const [libraryName, libraryAddress] of typedObjectEntries(libraries)) {
    const contractIdAddress = libraryAddress instanceof ContractId ? libraryAddress : /\d+\.\d+\.\d+/.test(libraryAddress) ? ContractId.fromString(libraryAddress) : null;
    const resolutedLibraryAddress = contractIdAddress !== null ? `0x${contractIdAddress.toSolidityAddress()}` : libraryAddress.toLowerCase();
    const newLibraryKey = libraryName.indexOf(":") !== -1 ? libraryName : `${VIRTUAL_SOURCE_CONTRACT_FILE_NAME}:${libraryName}`;
    solidityLibraries[newLibraryKey] = resolutedLibraryAddress;
  }
  return solidityLibraries;
}

/**
 * The Solidity-backed, non-deployed, data-holder for a Smart Contract logic.
 */
class Contract extends BasicUploadableEntity {
  /**
   * Given an index or a name, this returns a specific {@link Contract} following the successful compilation of
   * either the contract code itself ({@link options.code}) or the solidity file located at the provided {@link options.path}
   *
   * In terms of precedence, it first checks to see if the {@link options.name} is provided and, if so, it uses that otherwise
   * it looks at the {@link options.index} one and goes with that.
   *
   * @param {Object} options - Provides a source and controls various {@see Contract} construction settings
   * @returns {Promise<Contract>}
   */
  static async newFrom({
    code,
    index = 0,
    ignoreWarnings = false,
    libraries,
    name,
    path
  }) {
    if (!code && !path) {
      throw new Error("In order to continue, either provide the direct solidity code or a file path where the top-level code resides.");
    }
    if (!name && (!!index || Number.isInteger(index) && index < 0)) {
      throw new Error("Please provide either a non-negative index or the actual name of the contract to reference the Contract instance with.");
    }
    const contracts = await Contract.getContractsObjectFor({
      code,
      ignoreWarnings,
      libraries,
      path
    });
    const contractNames = Object.keys(contracts);
    const numberOfContracts = contractNames.length;
    if (name) {
      const contractOfInterest = await contracts[name]();
      if (!contractOfInterest) {
        throw new Error(`There is no such contract named '${name}' present in the referenced code.`);
      }
      return contractOfInterest;
    } else if (index >= numberOfContracts) {
      throw new Error(`Index out of range. Your requested contract-id ${index} is not in range of the ${numberOfContracts} contracts present in the given code.`);
    }
    const contractOfInterestName = contractNames[index];
    return await contracts[contractOfInterestName]();
  }

  /**
   * Returns all the contracts present in the given `options` (either from `path` or from `code`) and, potentially, linked against the `libraries`.
   *
   * @param {AllContractOptions} opts - Provides a source and controls various {@see Contract} construction settings.
   * @returns {Promise<Array<Contract>>} - A list of {@link Contract}s parsed via Hedera's officially supported solidity version compiler (`solc`) from the code
   */
  static async allFrom(opts) {
    const optsWithDefaults = Object.assign({
      allOrNothing: true,
      ignoreWarnings: false
    }, opts);
    const allPromisedContracts = await Contract.getContractsObjectFor(optsWithDefaults);
    const contracts = [];
    for (const promisedContract of Object.values(allPromisedContracts)) {
      try {
        contracts.push(await promisedContract());
      } catch (e) {
        if (optsWithDefaults.allOrNothing) {
          throw e;
        }
      }
    }
    return contracts;
  }

  /**
   * Deserializes the provided Contract representation which is assumed to be the output of the {@link Contract.serialize} method call.
   */
  static deserialize(what) {
    let jWhat = {};
    try {
      jWhat = JSON.parse(what);
    } catch (e) {
      throw new Error("Please provide something valid to be deserialized.");
    }
    return new Contract(jWhat);
  }

  /**
   * Returns an object of promised contracts which are present as resolved by the given `options` (eg. either from `path` or from `code`) and,
   * which potentially, are linked against the provided `libraries`.
   *
   * Note: Resolving the actual entries might fail due to linking issues and should be accounted for.
   */
  static async getContractsObjectFor({
    code,
    ignoreWarnings = false,
    libraries,
    path
  }) {
    if (!code && !path) {
      throw new Error("Can only retrieve contracts if either the direct solidity code is provided or a file path where that top-level code resides.");
    }
    const compileResult = await SolidityCompiler.compile({
      code,
      path
    });
    CompileIssues.tryThrowingIfErrorsIn({
      compileResult,
      ignoreWarnings
    });
    const solidityLibraries = mapToSolidityLibraries(libraries);
    const contracts = {};
    for (const compiledContract of compileResult.contracts) {
      let promisedContract;
      try {
        promisedContract = () => Promise.resolve(new Contract({
          abi: compiledContract.abi,
          byteCode: compiledContract.getLinkedByteCode(solidityLibraries),
          name: compiledContract.contractName
        }));
      } catch (e) {
        promisedContract = () => Promise.reject(`There was an issue while linking contract '${compiledContract.contractName}': ${e.message}`);
      }
      contracts[compiledContract.contractName] = promisedContract;
    }
    return contracts;
  }

  /**
   * The name of the referenced Solidity contract.
   * Note: this can be different then the source-file used to host it.
   */

  constructor({
    name,
    abi,
    byteCode
  }) {
    if (!name) {
      throw new Error("Please provide a name for the Contract instance.");
    } else if (!abi) {
      throw new Error("Please provide a, valid, EthersProject-compatible, ABI definition for the Contract instance.");
    } else if (typeof byteCode === "string" && byteCode.length !== 0) {
      if (/.*__\$.*\$__.*/.test(byteCode)) {
        throw new Error("Library linking is not currently supported. Please follow issue #38 for more info.");
      } else if (!/^[0-9a-f]+$/.test(byteCode)) {
        throw new Error("Please provide the valid formatted byte-code definition for the Contract in order to instantiate it.");
      }
    } else {
      // if byteCode.length === '', yet there is an ABI, this means that most likely the loaded contract is an abstract one
      // we permit this, but are weary when trying to upload it to a LiveContract. Basically, we won't allow uploading in this scenario.
    }
    super(`${name}-Contract`);
    this.name = name;
    this.byteCode = byteCode;
    this.interface = new Interface(abi);
  }

  /**
   * Tests if this contract is the same (functionally speaking) as another one.
   */
  equals(other) {
    if (other instanceof Contract === false) {
      return false;
    }
    const thisFragments = this.interface.fragments;
    const otherFragments = other.interface.fragments;
    if (thisFragments.length !== otherFragments.length) {
      return false;
    }
    let areAbisTheSame = true;
    for (const thisFragment of thisFragments) {
      if (!otherFragments.find(otherFragment => otherFragment.format() === thisFragment.format())) {
        areAbisTheSame = false;
        break;
      }
    }
    return this.byteCode === other.byteCode && areAbisTheSame;
  }

  /**
   * Serializes the current entity. This then can be reversed via calling {@link Contract.deserialize}.
   *
   * Note: when de-serializing, the properties exported here should allow for a complete re-instantiation of the original {@link Contract}.
   *
   * @returns {string} - The serialized representation of the current instance
   */
  serialize() {
    return JSON.stringify({
      abi: this.interface.format(),
      byteCode: this.byteCode,
      name: this.name
    });
  }
  async getContent() {
    if (!this.byteCode) {
      throw new Error("Won't upload contract to network because it's lacking the required byte-code data.");
    }
    return this.byteCode;
  }

  /**
   * Having a file-create {@link receipt} provided, this function uses it to create a contract via the Hedera Contract Service (HCS). The provided {@link args}
   * are used both to populate the {@link ContractCreateTransaction} constructor (if the first object from the list has a '_contract' property) and to pass along
   * as constructor arguments when publishing the Contract.
   * If there is a constructor config object present (first args from list if it has the '_contract' property) this is consumed and the remainder of the arguments
   * are passed to the Contract constructor.
   */
  async onFileUploaded({
    session,
    receipt,
    args = []
  }) {
    const {
      createContractOptions,
      emitConstructorLogs
    } = await this._getContractCreateOptionsFor({
      args,
      receipt,
      session
    });
    const createContractTransaction = new ContractCreateTransaction(createContractOptions);
    return await LiveContract.newFollowingUpload({
      contract: this,
      emitConstructorLogs,
      session,
      transaction: createContractTransaction
    });
  }
  async _getContractCreateOptionsFor({
    session,
    receipt,
    args = []
  }) {
    const contractFileId = receipt.fileId;
    let contractCreationOverrides = {};
    let emitConstructorLogs = session.defaults.emitConstructorLogs;
    if (args.length > 0 && Object.keys(args[0]).length !== 0 && Object.keys(args[0])[0] === "_contract") {
      const contractCreationArgs = args[0]._contract;

      // try locking onto library-controlling behavior flags
      emitConstructorLogs = contractCreationArgs.emitConstructorLogs !== undefined ? contractCreationArgs.emitConstructorLogs : emitConstructorLogs;
      delete contractCreationArgs.emitConstructorLogs;

      // consider everything else as contract-creation constructor arguments
      contractCreationOverrides = contractCreationArgs;
      args = args.slice(1);
    }
    return {
      createContractOptions: Object.assign({}, {
        adminKey: session.wallet.account.publicKey,
        bytecodeFileId: contractFileId,
        constructorParameters: new StratoContractArgumentsEncoder(this.interface).encode(args),
        gas: session.defaults.contractCreationGas,
        ...contractCreationOverrides
      }),
      emitConstructorLogs
    };
  }
}

var _hashgraphVenin_ContractRegistry = {
    "distribution/HstDistribution": ["constructor(address hstTokenAddress, address _treasuryAddress)","error NotRecipient()","error NothingToWithdraw(address recipient)","event AllocationWithdrawn(address indexed recipient, uint256 value)","event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)","event RecipientAdded(address indexed recipient, uint256 indexed firstReleaseDateSeconds, uint256 indexed releaseIntervalSeconds, uint256 releaseAmountTiny, uint8 noOfReleasesFromStart)","event RecipientRemoved(address indexed recipient)","event TreasuryUpdated(address indexed treasury)","function addRecipient(address recipient, uint256 firstReleaseDateSeconds, uint256 releaseIntervalSeconds, uint256 releaseAmountTiny, uint8 noOfReleasesFromStart)","function allocationInfo(address recipient) view returns (tuple(uint256 firstReleaseDateSeconds, uint256 releaseIntervalSeconds, uint256 releaseAmountTiny, uint256 withdrawn, uint8 noOfReleases) allocation)","function calculateVestedAmount(address recipient) view returns (uint256)","function owner() view returns (address)","function removeRecipient(address recipient)","function renounceOwnership()","function transferOwnership(address newOwner)","function treasuryAddress() view returns (address)","function updateTreasury(address _treasuryAddress)","function withdrawAllocation()"],"distribution/IHstDistribution": ["error NotRecipient()","error NothingToWithdraw(address recipient)","event AllocationWithdrawn(address indexed recipient, uint256 value)","event RecipientAdded(address indexed recipient, uint256 indexed firstReleaseDateSeconds, uint256 indexed releaseIntervalSeconds, uint256 releaseAmountTiny, uint8 noOfReleasesFromStart)","event RecipientRemoved(address indexed recipient)","event TreasuryUpdated(address indexed treasury)","function addRecipient(address recipient, uint256 firstReleaseDateSeconds, uint256 releaseIntervalSeconds, uint256 releaseAmountTiny, uint8 noOfReleasesFromStart)","function allocationInfo(address recipient) view returns (tuple(uint256 firstReleaseDateSeconds, uint256 releaseIntervalSeconds, uint256 releaseAmountTiny, uint256 withdrawn, uint8 noOfReleases) allocation)","function calculateVestedAmount(address recipient) view returns (uint256)","function removeRecipient(address recipient)","function updateTreasury(address _treasuryAddress)","function withdrawAllocation()"],"hedera/HederaExchangeRateService": [],"hedera/HederaPrngService": [],"hedera/HederaTokenService": [],"hedera/IHederaTokenService": [],"idos/AccessControlPool": ["error AccessDenied()","error InvalidPoolDate()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function claim(address _address)","function depositToken(uint64 value)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function withdraw()","function withdrawUnsoldTokens()"],"idos/BasicPool": ["constructor(address _tokenAddress, uint256 _pricePerToken, uint64 _tokenClaimMax, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","error AccessDenied()","error InvalidPoolDate()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/IDOPool": ["constructor(address _tokenAddress, uint256 _pricePerToken, uint64 _tokenClaimMax, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","error AccessDenied()","error InvalidPoolDate()","error NotAllowlisted(address _address)","event AddressAllowlisted(address indexed _address)","event AddressDenylisted(address indexed _address)","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function allowlistMultiple(address[] _addresses)","function allowlistSingle(address _address)","function claim(address _address)","function denylistMultiple(address[] _addresses)","function denylistSingle(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function isAllowlisted(address _address) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/IDOPoolWithVesting": ["constructor(address _tokenAddress, uint256 _pricePerToken, uint64 _tokenClaimMax, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds, uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage)","error AccessDenied()","error InvalidPoolDate()","error NotAllowlisted(address _address)","event AddressAllowlisted(address indexed _address)","event AddressDenylisted(address indexed _address)","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event ScheduledVesting(uint256 initialReleasePercentage, uint256 releasesCount, uint256 releaseIntervalDuration)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function allowlistMultiple(address[] _addresses)","function allowlistSingle(address _address)","function calculateClaimableAmount(address _address) returns (uint64)","function claim(address _address)","function denylistMultiple(address[] _addresses)","function denylistSingle(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getTotalClaimed(address _address) view returns (uint64)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialReleasePercentage() view returns (uint256)","function isAllowlisted(address _address) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function releaseIntervalDuration() view returns (uint256)","function releasesCount() view returns (uint256)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function setVestingSchedule(uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/MerkleIDOPool": ["constructor(address _tokenAddress, uint256 _pricePerToken, uint64 _tokenClaimMax, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds, bytes32 _merkleRoot)","error AccessDenied()","error InvalidPoolDate()","error NotInMerkle()","error Unauthorized()","event MerkleRootSet(bytes32 merkleRoot)","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function joinWithProof(address _address, uint64 amount, bytes32[] proof) payable","function merkleRoot() view returns (bytes32)","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function updateMerkleRoot(bytes32 _merkleRoot)","function withdraw()","function withdrawUnsoldTokens()"],"idos/MerkleIDOPoolWithVesting": ["constructor(address _tokenAddress, uint256 _pricePerToken, uint64 _tokenClaimMax, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds, uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage, bytes32 _merkleRoot)","error AccessDenied()","error InvalidPoolDate()","error NotInMerkle()","error Unauthorized()","event MerkleRootSet(bytes32 merkleRoot)","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event ScheduledVesting(uint256 initialReleasePercentage, uint256 releasesCount, uint256 releaseIntervalDuration)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function calculateClaimableAmount(address _address) returns (uint64)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getTotalClaimed(address _address) view returns (uint64)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialReleasePercentage() view returns (uint256)","function joinPool(address _address, uint64 amount) payable","function joinWithProof(address _address, uint64 amount, bytes32[] proof) payable","function merkleRoot() view returns (bytes32)","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function releaseIntervalDuration() view returns (uint256)","function releasesCount() view returns (uint256)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function setVestingSchedule(uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function updateMerkleRoot(bytes32 _merkleRoot)","function withdraw()","function withdrawUnsoldTokens()"],"idos/extensions/AllowlistPool": ["error AccessDenied()","error InvalidPoolDate()","error NotAllowlisted(address _address)","event AddressAllowlisted(address indexed _address)","event AddressDenylisted(address indexed _address)","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function allowlistMultiple(address[] _addresses)","function allowlistSingle(address _address)","function claim(address _address)","function denylistMultiple(address[] _addresses)","function denylistSingle(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function isAllowlisted(address _address) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/extensions/MerklePool": ["error AccessDenied()","error InvalidPoolDate()","error NotInMerkle()","error Unauthorized()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function joinWithProof(address _address, uint64 amount, bytes32[] proof) payable","function merkleRoot() view returns (bytes32)","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/extensions/MerklePoolV2": ["error AccessDenied()","error InvalidPoolDate()","error NotInMerkle()","error Unauthorized()","event MerkleRootSet(bytes32 merkleRoot)","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function joinWithProof(address _address, uint64 amount, bytes32[] proof) payable","function merkleRoot() view returns (bytes32)","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function updateMerkleRoot(bytes32 _merkleRoot)","function withdraw()","function withdrawUnsoldTokens()"],"idos/extensions/MultiPartyWithdrawPool": ["error AccessDenied()","error InvalidInitialization()","error InvalidPoolDate()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function parties(uint256) view returns (address party, uint256 shares)","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function totalShares() view returns (uint256)","function withdraw()","function withdrawUnsoldTokens()"],"idos/extensions/VestingPool": ["error AccessDenied()","error InvalidPoolDate()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event ScheduledVesting(uint256 initialReleasePercentage, uint256 releasesCount, uint256 releaseIntervalDuration)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function calculateClaimableAmount(address _address) returns (uint64)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getTotalClaimed(address _address) view returns (uint64)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialReleasePercentage() view returns (uint256)","function joinPool(address _address, uint64 amount) payable","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function releaseIntervalDuration() view returns (uint256)","function releasesCount() view returns (uint256)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function setVestingSchedule(uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/interfaces/IPool": ["error AccessDenied()","error InvalidPoolDate()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function claim(address _address)","function depositToken(uint64 value)","function getAllocation(address _address) view returns (uint64)","function joinPool(address _address, uint64 amount) payable","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function withdraw()","function withdrawUnsoldTokens()"],"idos/mocks/BasicPoolMock": ["constructor(address _tokenAddress, uint64 _tokenClaimMax, uint64 _pricePerToken, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","error AccessDenied()","error InvalidPoolDate()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/mocks/PoolAllowlist": ["constructor(address _tokenAddress, uint64 _tokenClaimMax, uint64 _pricePerToken, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","error AccessDenied()","error InvalidPoolDate()","error NotAllowlisted(address _address)","event AddressAllowlisted(address indexed _address)","event AddressDenylisted(address indexed _address)","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function allowlistMultiple(address[] _addresses)","function allowlistSingle(address _address)","function claim(address _address)","function denylistMultiple(address[] _addresses)","function denylistSingle(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function isAllowlisted(address _address) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/mocks/PoolMerkle": ["constructor(address _tokenAddress, uint64 _tokenClaimMax, uint64 _pricePerToken, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds, bytes32 _merkleRoot)","error AccessDenied()","error InvalidPoolDate()","error NotInMerkle()","error Unauthorized()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function joinWithProof(address _address, uint64 amount, bytes32[] proof) payable","function merkleRoot() view returns (bytes32)","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/mocks/PoolMultiPartyWithdraw": ["constructor(address _tokenAddress, uint64 _tokenClaimMax, uint64 _pricePerToken, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds, address[] _withdrawParties, uint256[] _withdrawPercentages)","error AccessDenied()","error InvalidInitialization()","error InvalidPoolDate()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function joinPool(address _address, uint64 amount) payable","function parties(uint256) view returns (address party, uint256 shares)","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function totalShares() view returns (uint256)","function withdraw()","function withdrawUnsoldTokens()"],"idos/mocks/PoolWithVesting": ["constructor(address _tokenAddress, uint64 _tokenClaimMax, uint64 _pricePerToken, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds, uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage)","error AccessDenied()","error InvalidPoolDate()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event ScheduledVesting(uint256 initialReleasePercentage, uint256 releasesCount, uint256 releaseIntervalDuration)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function calculateClaimableAmount(address _address) returns (uint64)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getTotalClaimed(address _address) view returns (uint64)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialReleasePercentage() view returns (uint256)","function joinPool(address _address, uint64 amount) payable","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function releaseIntervalDuration() view returns (uint256)","function releasesCount() view returns (uint256)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function setVestingSchedule(uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"idos/mocks/PoolWithVestingMock": ["constructor(address _tokenAddress, uint64 _tokenClaimMax, uint64 _pricePerToken, uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds, uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage)","error AccessDenied()","error InvalidPoolDate()","event PoolInitialized(address indexed tokenAddress, uint256 pricePerToken, uint64 tokenClaimMax)","event PoolJoin(address indexed _address, uint64 value, uint64 tokensSold)","event PoolScheduleSet(uint64 startTime, uint64 endTime, uint256 redeemTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event ScheduledVesting(uint256 initialReleasePercentage, uint256 releasesCount, uint256 releaseIntervalDuration)","event TokenClaim(address indexed _address, uint64 value)","event TokenDeposit(address indexed from, uint64 value)","event TokenWithdraw(address indexed to, uint64 value)","event Withdraw(address indexed to, uint256 value)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function POOL_OWNER_ROLE() view returns (bytes32)","function POOL_PLANNER_ROLE() view returns (bytes32)","function calculateClaimableAmount(address _address) returns (uint64)","function claim(address _address)","function depositToken(uint64 value)","function endDateSeconds() view returns (uint64)","function entries(address) view returns (uint64)","function entriesCounter() view returns (uint64)","function getAllocation(address _address) view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getTotalClaimed(address _address) view returns (uint64)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialReleasePercentage() view returns (uint256)","function joinPool(address _address, uint64 amount) payable","function pricePerToken() view returns (uint256)","function redeemDateSeconds() view returns (uint64)","function releaseIntervalDuration() view returns (uint256)","function releasesCount() view returns (uint256)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setPoolSchedule(uint64 _startDateSeconds, uint64 _endDateSeconds, uint64 _redeemDateSeconds)","function setTokenIdoDetails(uint64 _tokenClaimMax, uint64 _pricePerToken)","function setVestingSchedule(uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage)","function startDateSeconds() view returns (uint64)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenClaimMax() view returns (uint64)","function tokensAllocated() view returns (uint64)","function withdraw()","function withdrawUnsoldTokens()"],"inos/BasicNFTStorefront": ["constructor(string _metadata, address owner, uint64 price, bool _isUniqueMetadata)","event Burn(int64[] serialNumbers)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function updateCollectionPrice(uint64 price)","function withdraw()"],"inos/DiscountedMultiRoundTokenGatedStorefront": ["constructor(string _metadata, address owner, uint256 _tokenGatedStartTime, uint256 _startTimeSale, uint64 price, uint64 startTimeMaxSales, bool _isUniqueMetadata)","error Unauthorized()","event Burn(int64[] serialNumbers)","event BurningToggled(bool enabled)","event DiscountedTokenAllowanceAdded(address indexed token, uint128 maxSales, uint128 discount)","event DiscountedTokenGatedStartTimeSet(uint256 startTime)","event DiscountedTokenMarkAsUsed(address indexed token, uint256 serial, uint256 maxSalesUsed)","event MaxSalesUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event MintingToggled(bool enabled)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event SaleStartTime(uint256 saleStartTime)","event TokenCreated(address tokenAddress, uint64 maxSupply)","event TokenGatedUserSale(address indexed _address, uint256 amount, uint256 price)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addDiscountedTokenAllowance(address token, uint128 maxSales, uint128 bpDiscount)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function buyCollectionForNfts(tuple(address tokenId, uint64[] serialNumbers)[] tokenSerials, uint256 mintAmount) payable","function getCollectionMaxSales() view returns (uint256)","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setStartTime(uint256 _saleStartTime)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function toggleBurning()","function toggleMinting()","function updateCollectionMaxSales(uint64 maxSales)","function updateCollectionPrice(uint64 price)","function updateTokenGatedStartTime(uint256 _startTime)","function withdraw()"],"inos/EarthlingsStorefront": ["constructor(string _metadata, address owner, uint256 _tokenSerialGatedStartTime, uint256 _tokenGatedStartTime, uint64 price, uint64 maxSales, bool _isUniqueMetadata)","error Unauthorized()","event Burn(int64[] serialNumbers)","event BurningToggled(bool enabled)","event MaxSalesTokenGatedUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event MintingToggled(bool enabled)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenAllowanceAdded(address indexed token)","event TokenCreated(address tokenAddress, uint64 maxSupply)","event TokenGatedStartTimeSet(uint256 startTime)","event TokenGatedUserSale(address indexed _address, uint256 amount)","event TokenMarkAsUsed(address indexed token, uint256 serial)","event TokenSerialAllowanceAdded(address indexed token, uint64 serial)","event TokenSerialGatedStartTimeSet(uint256 startTime)","event TokenSerialMarkAsUsed(address indexed holder, address indexed token, uint64 serial)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTokenAllowance(address token)","function addTokenSerialAllowance(address token, uint64[] serials)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function buyCollectionForNfts(tuple(address tokenId, uint64[] serialNumbers)[] tokenSerials) payable","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function getTokenGatedMaxSales() view returns (uint256)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function toggleBurning()","function toggleMinting()","function updateCollectionPrice(uint64 price)","function updateTokenGatedMaxSales(uint64 maxSales)","function updateTokenGatedStartTime(uint256 _startTime)","function updateTokenSerialGatedStartTime(uint256 _startTime)","function withdraw()"],"inos/INFTStorefront": ["event Burn(int64[] serialNumbers)","event Mint(address minter, int64[] serialNumbers)","event PriceUpdate(uint64 price)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionPrice() view returns (uint64)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function updateCollectionPrice(uint64 price)","function withdraw()"],"inos/NFTStorefront": ["constructor(string _metadata, address owner, bool isUnique, uint64 maxBuy, uint64 price)","event Burn(int64[] serialNumbers)","event BurningToggled(bool enabled)","event MaxSalesUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event MintingToggled(bool enabled)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionMaxSales() view returns (uint256)","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function toggleBurning()","function toggleMinting()","function updateCollectionMaxSales(uint64 maxSales)","function updateCollectionPrice(uint64 price)","function withdraw()"],"inos/StandardTokenGatedStorefront": ["constructor(string _metadata, address owner, uint256 tokenGatedStartTime, uint256 publicStartTime, uint256 publicEndTime, uint64 price, uint64 publicMaxSales, bool isUniqueMetadata)","event Burn(int64[] serialNumbers)","event BurningToggled(bool enabled)","event DiscountedTokenAllowanceAdded(address indexed token, uint128 maxSales, uint128 discount)","event DiscountedTokenGatedStartTimeSet(uint256 startTime)","event DiscountedTokenMarkAsUsed(address indexed token, uint256 serial, uint256 maxSalesUsed)","event MaxSalesUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event MintingToggled(bool enabled)","event PriceUpdate(uint64 price)","event PublicSaleTimesSet(uint256 saleStartTime, uint256 saleEndTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","event TokenGatedUserSale(address indexed _address, uint256 amount, uint256 price)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addDiscountedTokenAllowance(address token, uint128 maxSales, uint128 bpDiscount)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function buyCollectionForNfts(tuple(address tokenId, uint64[] serialNumbers)[] tokenSerials, uint256 mintAmount) payable","function getCollectionMaxSales() view returns (uint256)","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setTimes(uint256 _saleStartTime, uint256 _saleEndTime)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function toggleBurning()","function toggleMinting()","function updateCollectionMaxSales(uint64 maxSales)","function updateCollectionPrice(uint64 price)","function updateTokenGatedStartTime(uint256 _startTime)","function withdraw()"],"inos/StandardizedStorefrontSale": ["constructor(string _metadata, address owner, uint64 price, bool _isUniqueMetadata, bytes32 _merkleRoot, uint256 _merkleStartTime, uint256 _saleStartTime, uint256 _saleEndTime, uint64 _maxSalesPerAddress)","event Burn(int64[] serialNumbers)","event BurningToggled(bool enabled)","event MaxSalesUpdate(uint64 maxSales)","event MerkleMint(bytes32 leaf, address account, uint64 nftsBought)","event MerkleRootSet(bytes32 merkleRoot)","event MerkleStartTimeSet(uint256 startTime)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event MintingToggled(bool enabled)","event PriceUpdate(uint64 price)","event PublicSaleTimesSet(uint256 saleStartTime, uint256 saleEndTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionMaxSales() view returns (uint256)","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function joinWithMerkle(address addr, uint256 amount, uint256 discount, bytes32[] proof, uint64 noOfNftsToBuy) payable","function merkleRoot() view returns (bytes32)","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setTimes(uint256 _saleStartTime, uint256 _saleEndTime)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function toggleBurning()","function toggleMinting()","function updateCollectionMaxSales(uint64 maxSales)","function updateCollectionPrice(uint64 price)","function updateMerkleRoot(bytes32 _merkleRoot)","function updateMerkleStartTime(uint256 _startTime)","function withdraw()"],"inos/StorefrontDeployer": ["event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)","event StorefrontDeployed(address storefrontAddress, string metadata)","event StorefrontRemoved(address storefrontAddress)","function deployStorefront(string metadata, bool isUnique, uint64 salesPerAccount, uint64 price)","function owner() view returns (address)","function removeStorefront(address storefrontAddress)","function renounceOwnership()","function transferOwnership(address newOwner)"],"inos/TokenGatedStorefrontSale": ["constructor(string _metadata, address owner, uint256 _tokenGatedStartTime, uint64 price, uint64 maxSales, bool _isUniqueMetadata)","error Unauthorized()","event Burn(int64[] serialNumbers)","event BurningToggled(bool enabled)","event MaxSalesTokenGatedUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event MintingToggled(bool enabled)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenAllowanceAdded(address indexed token)","event TokenCreated(address tokenAddress, uint64 maxSupply)","event TokenGatedStartTimeSet(uint256 startTime)","event TokenGatedUserSale(address indexed _address, uint256 amount)","event TokenMarkAsUsed(address indexed token, uint256 serial)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTokenAllowance(address token)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function buyCollectionForNfts(tuple(address tokenId, uint64[] serialNumbers)[] tokenSerials) payable","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function getTokenGatedMaxSales() view returns (uint256)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function toggleBurning()","function toggleMinting()","function updateCollectionPrice(uint64 price)","function updateTokenGatedMaxSales(uint64 maxSales)","function updateTokenGatedStartTime(uint256 _startTime)","function withdraw()"],"inos/TriRoundStorefront": ["constructor(string _metadata, address owner, uint256 _tokenSerialGatedStartTime, uint256 _tokenGatedStartTime, uint256 _startTimeSale, uint64 price, uint64 _tokenGatedMaxSales, uint64 startTimeMaxSales, bool _isUniqueMetadata)","event Burn(int64[] serialNumbers)","event BurningToggled(bool enabled)","event MaxSalesTokenGatedUpdate(uint64 maxSales)","event MaxSalesUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event MintingToggled(bool enabled)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event SaleStartTime(uint256 saleStartTime)","event TokenAllowanceAdded(address indexed token)","event TokenCreated(address tokenAddress, uint64 maxSupply)","event TokenGatedStartTimeSet(uint256 startTime)","event TokenGatedUserSale(address indexed _address, uint256 amount)","event TokenMarkAsUsed(address indexed token, uint256 serial)","event TokenSerialAllowanceAdded(address indexed token, uint64 serial)","event TokenSerialGatedStartTimeSet(uint256 startTime)","event TokenSerialMarkAsUsed(address indexed holder, address indexed token, uint64 serial)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTokenAllowance(address token)","function addTokenSerialAllowance(address token, uint64[] serials)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function buyCollectionForNfts(tuple(address tokenId, uint64[] serialNumbers)[] tokenSerials) payable","function getCollectionMaxSales() view returns (uint256)","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function getTokenGatedMaxSales() view returns (uint256)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setStartTime(uint256 _saleStartTime)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function toggleBurning()","function toggleMinting()","function updateCollectionMaxSales(uint64 maxSales)","function updateCollectionPrice(uint64 price)","function updateTokenGatedMaxSales(uint64 maxSales)","function updateTokenGatedStartTime(uint256 _startTime)","function updateTokenSerialGatedStartTime(uint256 _startTime)","function withdraw()"],"inos/core/NftManager": ["event MetadataDefined(string metadata, uint256 isUnique)","event TokenCreated(address tokenAddress, uint64 maxSupply)","function getTokenAddress() view returns (address)"],"inos/core/SaleRandomizer": [],"inos/extensions/DiscountedTokenGatedSale": ["event Burn(int64[] serialNumbers)","event DiscountedTokenAllowanceAdded(address indexed token, uint128 maxSales, uint128 discount)","event DiscountedTokenGatedStartTimeSet(uint256 startTime)","event DiscountedTokenMarkAsUsed(address indexed token, uint256 serial, uint256 maxSalesUsed)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","event TokenGatedUserSale(address indexed _address, uint256 amount, uint256 price)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addDiscountedTokenAllowance(address token, uint128 maxSales, uint128 bpDiscount)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function updateCollectionPrice(uint64 price)","function updateTokenGatedStartTime(uint256 _startTime)","function withdraw()"],"inos/extensions/MaxSalesStorefront": ["event Burn(int64[] serialNumbers)","event MaxSalesUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionMaxSales() view returns (uint256)","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function updateCollectionMaxSales(uint64 maxSales)","function updateCollectionPrice(uint64 price)","function withdraw()"],"inos/extensions/MerkleSale": ["event Burn(int64[] serialNumbers)","event MerkleMint(bytes32 leaf, address account, uint64 nftsBought)","event MerkleRootSet(bytes32 merkleRoot)","event MerkleStartTimeSet(uint256 startTime)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function joinWithMerkle(address addr, uint256 amount, uint256 discount, bytes32[] proof, uint64 noOfNftsToBuy) payable","function merkleRoot() view returns (bytes32)","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function updateCollectionPrice(uint64 price)","function updateMerkleRoot(bytes32 _merkleRoot)","function updateMerkleStartTime(uint256 _startTime)","function withdraw()"],"inos/extensions/PausableStorefront": ["event Burn(int64[] serialNumbers)","event BurningToggled(bool enabled)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event MintingToggled(bool enabled)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function toggleBurning()","function toggleMinting()","function updateCollectionPrice(uint64 price)","function withdraw()"],"inos/extensions/PublicSale": ["event Burn(int64[] serialNumbers)","event MaxSalesUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event PriceUpdate(uint64 price)","event PublicSaleTimesSet(uint256 saleStartTime, uint256 saleEndTime)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionMaxSales() view returns (uint256)","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setTimes(uint256 _saleStartTime, uint256 _saleEndTime)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function updateCollectionMaxSales(uint64 maxSales)","function updateCollectionPrice(uint64 price)","function withdraw()"],"inos/extensions/StartTimeSale": ["event Burn(int64[] serialNumbers)","event MaxSalesUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event SaleStartTime(uint256 saleStartTime)","event TokenCreated(address tokenAddress, uint64 maxSupply)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionMaxSales() view returns (uint256)","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function setStartTime(uint256 _saleStartTime)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function updateCollectionMaxSales(uint64 maxSales)","function updateCollectionPrice(uint64 price)","function withdraw()"],"inos/extensions/TokenGatedSale": ["event Burn(int64[] serialNumbers)","event MaxSalesTokenGatedUpdate(uint64 maxSales)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenAllowanceAdded(address indexed token)","event TokenCreated(address tokenAddress, uint64 maxSupply)","event TokenGatedStartTimeSet(uint256 startTime)","event TokenGatedUserSale(address indexed _address, uint256 amount)","event TokenMarkAsUsed(address indexed token, uint256 serial)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTokenAllowance(address token)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function getTokenGatedMaxSales() view returns (uint256)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function updateCollectionPrice(uint64 price)","function updateTokenGatedMaxSales(uint64 maxSales)","function updateTokenGatedStartTime(uint256 _startTime)","function withdraw()"],"inos/extensions/TokenSerialGatedSale": ["event Burn(int64[] serialNumbers)","event MetadataDefined(string metadata, uint256 isUnique)","event Mint(address minter, int64[] serialNumbers)","event PriceUpdate(uint64 price)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event TokenCreated(address tokenAddress, uint64 maxSupply)","event TokenSerialAllowanceAdded(address indexed token, uint64 serial)","event TokenSerialGatedStartTimeSet(uint256 startTime)","event TokenSerialMarkAsUsed(address indexed holder, address indexed token, uint64 serial)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function MINTER_ROLE() view returns (bytes32)","function TREASURY_ROLE() view returns (bytes32)","function addMinter(address minterAddress)","function addTokenSerialAllowance(address token, uint64[] serials)","function addTreasuryAccount(address treasury)","function burnSerials(int64[] serialNumbers)","function buyCollection(uint64 noOfSerials) payable","function getCollectionPrice() view returns (uint64)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function getTokenAddress() view returns (address)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function initialize(string name, string symbol, uint64 _maxSupply, uint32 _multiplier, uint32 _increment) payable","function initializeWithExistingToken(address _tokenAddress, uint64 _maxSupply, uint32 _multiplier, uint32 _increment)","function initializeWithFees(string name, string symbol, address collector, uint64 _maxSupply, uint32 numerator, uint32 denominator, uint32 _multiplier, uint32 _increment) payable","function mintAsAdmin(uint64 noOfSerials)","function removeMinter(address minterAddress)","function removeTreasuryAccount(address treasury)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function updateCollectionPrice(uint64 price)","function updateTokenSerialGatedStartTime(uint256 _startTime)","function withdraw()"],"inos/token_redeem/ITokenRedeemer": ["event CollectionAdded(address indexed collectionAddress, address indexed nftAddress, address indexed tokenAddress, uint256 totalRedeemValue, uint256 initialReleasePercentage, uint256 noOfFutureReleases, uint256 intervalBetweenReleases)","event RedemptionClaim(address indexed redeemer, uint256 indexed redemptionId, uint256 value)","event TokenRedeemStart(address indexed redeemer, address indexed nftAddress, uint256 noOfNfts, uint256 redemptionId)","event TokenTreasurySet(address indexed tokenAddress, address indexed treasuryAddress)","function addNewCollection(address collectionAddress, address nftAddress, address tokenAddress, uint256 totalRedeemValue, uint256 initialReleasePercentage, uint256 noOfFutureReleases, uint256 intervalBetweenReleases) payable","function addNewRedeemableToken(address tokenAddress, address treasuryAddress)","function approve(address nftAddress) payable","function modifyRedeemableToken(address tokenAddress, address treasuryAddress)","function redeemVestedTokens(uint256 redemptionId)","function startRedemption(address nftAddress, int64[] serialNumbers)","function startRedemptionCustodial(address nftAddress, int64[] serialNumbers)"],"inos/token_redeem/TokenRedeemer": ["event CollectionAdded(address indexed collectionAddress, address indexed nftAddress, address indexed tokenAddress, uint256 totalRedeemValue, uint256 initialReleasePercentage, uint256 noOfFutureReleases, uint256 intervalBetweenReleases)","event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)","event RedemptionClaim(address indexed redeemer, uint256 indexed redemptionId, uint256 value)","event TokenRedeemStart(address indexed redeemer, address indexed nftAddress, uint256 noOfNfts, uint256 redemptionId)","event TokenTreasurySet(address indexed tokenAddress, address indexed treasuryAddress)","function addNewCollection(address collectionAddress, address nftAddress, address tokenAddress, uint256 totalRedeemValue, uint256 initialReleasePercentage, uint256 noOfFutureReleases, uint256 intervalBetweenReleases) payable","function addNewRedeemableToken(address tokenAddress, address treasuryAddress)","function approve(address nftAddress) payable","function modifyRedeemableToken(address tokenAddress, address treasuryAddress)","function owner() view returns (address)","function redeemVestedTokens(uint256 redemptionId)","function redeemableCollections(address) view returns (address collectionAddress, address nftAddress, address tokenAddress, uint256 totalRedeemValue, uint256 initialReleasePercentage, uint256 noOfFutureReleases, uint256 intervalBetweenReleases)","function renounceOwnership()","function startRedemption(address nftAddress, int64[] serialNumbers)","function startRedemptionCustodial(address nftAddress, int64[] serialNumbers)","function tokenTreasuries(address) view returns (address)","function transferOwnership(address newOwner)","function userRedemptions(address, uint256) view returns (address nftAddress, uint256 redemptionStart, uint256 noOfNfts, uint256 tokensRedeemed)"],"mocks/ERC20Mock": ["event Approval(address indexed owner, address indexed spender, uint256 value)","event Transfer(address indexed from, address indexed to, uint256 value)","function allowance(address owner, address spender) view returns (uint256)","function approve(address spender, uint256 amount) returns (bool)","function balanceOf(address account) view returns (uint256)","function decimals() view returns (uint8)","function decreaseAllowance(address spender, uint256 subtractedValue) returns (bool)","function increaseAllowance(address spender, uint256 addedValue) returns (bool)","function mint(address user, uint256 amount)","function name() view returns (string)","function symbol() view returns (string)","function totalSupply() view returns (uint256)","function transfer(address recipient, uint256 amount) returns (bool)","function transferAmount() view returns (uint256)","function transferCalled() view returns (bool)","function transferFrom(address sender, address recipient, uint256 amount) returns (bool)","function transferFromCalled() view returns (bool)","function transferRecipient() view returns (address)"],"mocks/MockHbarTinycentsPriceProvider": ["function CONTRACT_ID() view returns (bytes32)","function contractId() view returns (bytes32)","function getPrice() pure returns (uint256)","function toTokenAmount(uint256 tinybars, uint256 tokenPriceTinycents) pure returns (uint256)"],"stakepools/BasicStakepool": ["constructor(address registryAddress, address deployer)","event Initialized(address token, uint256 tinycentsPerToken, uint256 depositTime, uint256 startTime, uint256 endTime)","event NewStakePeriodSet(address staker, uint256 effectiveDate, uint256 stakerHbarRaised, uint256 hbarRaised)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event Stake(address staker, uint256 amount)","event Unstake(address staker, uint256 amount)","event WithdrawReward(address staker, uint256 amount)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function HBAR_REWARD_RATE_CONTRACT_ID() view returns (bytes32)","function PRICE_PROVIDER_CONTRACT_ID() view returns (bytes32)","function ROLE_FACTORY() view returns (bytes32)","function ROLE_STAKEPOOL_ADMIN() view returns (bytes32)","function balanceOf(address) view returns (uint256)","function earned(address _account) returns (uint256)","function effectiveEpochStartOf(address) view returns (uint256)","function eventDepositStartSeconds() view returns (uint256)","function eventEndSeconds() view returns (uint256)","function eventStartSeconds() view returns (uint256)","function getReward()","function getRoleAdmin(bytes32 role) view returns (bytes32)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function hbarEarned(address _account) view returns (uint256)","function initialize(address _rewardToken, address _treasuryAddress, uint256 _tinycentsPerToken, uint256 _eventStartSeconds, uint256 _eventEndSeconds)","function initializeWithNewToken(string tokenName, uint256 _tinycentsPerToken, uint256 _eventStartSeconds, uint256 _eventEndSeconds) payable returns (address token)","function pendingHbarReward(address) view returns (uint256)","function registry() view returns (address)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function rewardsToken() view returns (address)","function stake() payable","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tinycentsPerToken() view returns (uint256)","function totalHbarRaised() view returns (uint256)","function totalSupply() view returns (uint256)","function treasuryAddress() view returns (address)","function withdraw(uint256 _amount)","function withdrawSurplus()"],"stakepools/IStakepool": ["event Initialized(address token, uint256 tinycentsPerToken, uint256 depositTime, uint256 startTime, uint256 endTime)","event NewStakePeriodSet(address staker, uint256 effectiveDate, uint256 stakerHbarRaised, uint256 hbarRaised)","event Stake(address staker, uint256 amount)","event Unstake(address staker, uint256 amount)","event WithdrawReward(address staker, uint256 amount)","function earned(address _account) returns (uint256)","function getReward()","function hbarEarned(address _account) view returns (uint256)","function initialize(address _rewardToken, address _treasuryAddress, uint256 _tinycentsPerToken, uint256 _eventStartSeconds, uint256 _eventEndSeconds)","function initializeWithNewToken(string tokenName, uint256 _tinycentsPerToken, uint256 _eventStartSeconds, uint256 _eventEndSeconds) payable returns (address token)","function stake() payable","function withdraw(uint256 _amount)","function withdrawSurplus()"],"stakepools/Stakepool": ["constructor(address registry, address deployer, uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage, uint256 _cliffTimestampSeconds)","event Initialized(address token, uint256 tinycentsPerToken, uint256 depositTime, uint256 startTime, uint256 endTime)","event NewStakePeriodSet(address staker, uint256 effectiveDate, uint256 stakerHbarRaised, uint256 hbarRaised)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event ScheduledVesting(uint256 initialReleasePercentage, uint256 releasesCount, uint256 releaseIntervalDuration, uint256 cliffTimestampSeconds)","event Stake(address staker, uint256 amount)","event Unstake(address staker, uint256 amount)","event WithdrawReward(address staker, uint256 amount)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function HBAR_REWARD_RATE_CONTRACT_ID() view returns (bytes32)","function PRICE_PROVIDER_CONTRACT_ID() view returns (bytes32)","function ROLE_FACTORY() view returns (bytes32)","function ROLE_STAKEPOOL_ADMIN() view returns (bytes32)","function balanceOf(address) view returns (uint256)","function calculateClaimableAmount(address _address) returns (uint256)","function cliffTimestampSeconds() view returns (uint256)","function earned(address _account) returns (uint256)","function effectiveEpochStartOf(address) view returns (uint256)","function eventDepositStartSeconds() view returns (uint256)","function eventEndSeconds() view returns (uint256)","function eventStartSeconds() view returns (uint256)","function getReward()","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getTotalClaimed(address _address) view returns (uint256)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function hbarEarned(address _account) view returns (uint256)","function initialReleasePercentage() view returns (uint256)","function initialize(address _rewardToken, address _treasuryAddress, uint256 _tinycentsPerToken, uint256 _eventStartSeconds, uint256 _eventEndSeconds)","function initializeWithNewToken(string tokenName, uint256 _tinycentsPerToken, uint256 _eventStartSeconds, uint256 _eventEndSeconds) payable returns (address token)","function pendingHbarReward(address) view returns (uint256)","function registry() view returns (address)","function releaseIntervalDuration() view returns (uint256)","function releasesCount() view returns (uint256)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function rewardsToken() view returns (address)","function setVestingSchedule(uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage, uint256 _cliffTimestampSeconds)","function stake() payable","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tinycentsPerToken() view returns (uint256)","function totalHbarRaised() view returns (uint256)","function totalSupply() view returns (uint256)","function treasuryAddress() view returns (address)","function withdraw(uint256 _amount)","function withdrawSurplus()"],"stakepools/StakepoolDeployer": ["constructor(address registryAddress)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event StakepoolCreated(address indexed tokenAddress, address indexed stakepoolAddress, uint256)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function ROLE_DEPLOYER() view returns (bytes32)","function createStakepool(address token, address treasuryAddress, uint256 tinycentsPerToken, uint256 eventStartSeconds, uint256 eventEndSeconds) returns (address stakepool)","function createStakepoolWithNewToken(string name, uint256 tinycentsPerToken, uint256 eventStartSeconds, uint256 eventEndSeconds) payable returns (address stakepool)","function createVestingStakepool(address token, address treasuryAddress, uint256 tinycentsPerToken, uint256 eventStartSeconds, uint256 eventEndSeconds, uint256 releasesCount, uint256 releaseIntervalDuration, uint256 initialReleasePercentage, uint256 cliffTimestampSeconds) returns (address stakepool)","function createVestingStakepoolWithNewToken(string name, uint256 tinycentsPerToken, uint256 eventStartSeconds, uint256 eventEndSeconds, uint256 releasesCount, uint256 releaseIntervalDuration, uint256 initialReleasePercentage, uint256 cliffTimestampSeconds) payable returns (address stakepool)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getRoleMember(bytes32 role, uint256 index) view returns (address)","function getRoleMemberCount(bytes32 role) view returns (uint256)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function registry() view returns (address)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function stakepools(uint256) view returns (address)","function stakepoolsCount() view returns (uint256)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tokenStakepool(address) view returns (address)"],"stakepools/extensions/Vesting": ["event Initialized(address token, uint256 tinycentsPerToken, uint256 depositTime, uint256 startTime, uint256 endTime)","event NewStakePeriodSet(address staker, uint256 effectiveDate, uint256 stakerHbarRaised, uint256 hbarRaised)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event ScheduledVesting(uint256 initialReleasePercentage, uint256 releasesCount, uint256 releaseIntervalDuration, uint256 cliffTimestampSeconds)","event Stake(address staker, uint256 amount)","event Unstake(address staker, uint256 amount)","event WithdrawReward(address staker, uint256 amount)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function HBAR_REWARD_RATE_CONTRACT_ID() view returns (bytes32)","function PRICE_PROVIDER_CONTRACT_ID() view returns (bytes32)","function ROLE_FACTORY() view returns (bytes32)","function ROLE_STAKEPOOL_ADMIN() view returns (bytes32)","function balanceOf(address) view returns (uint256)","function calculateClaimableAmount(address _address) returns (uint256)","function cliffTimestampSeconds() view returns (uint256)","function earned(address _account) returns (uint256)","function effectiveEpochStartOf(address) view returns (uint256)","function eventDepositStartSeconds() view returns (uint256)","function eventEndSeconds() view returns (uint256)","function eventStartSeconds() view returns (uint256)","function getReward()","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getTotalClaimed(address _address) view returns (uint256)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function hbarEarned(address _account) view returns (uint256)","function initialReleasePercentage() view returns (uint256)","function initialize(address _rewardToken, address _treasuryAddress, uint256 _tinycentsPerToken, uint256 _eventStartSeconds, uint256 _eventEndSeconds)","function initializeWithNewToken(string tokenName, uint256 _tinycentsPerToken, uint256 _eventStartSeconds, uint256 _eventEndSeconds) payable returns (address token)","function pendingHbarReward(address) view returns (uint256)","function registry() view returns (address)","function releaseIntervalDuration() view returns (uint256)","function releasesCount() view returns (uint256)","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function rewardsToken() view returns (address)","function setVestingSchedule(uint256 _releasesCount, uint256 _releaseIntervalDuration, uint256 _initialReleasePercentage, uint256 _cliffTimestampSeconds)","function stake() payable","function supportsInterface(bytes4 interfaceId) view returns (bool)","function tinycentsPerToken() view returns (uint256)","function totalHbarRaised() view returns (uint256)","function totalSupply() view returns (uint256)","function treasuryAddress() view returns (address)","function withdraw(uint256 _amount)","function withdrawSurplus()"],"stakepools/providers/ContractRegistry": ["event ImplementationSet(bytes32 contractId, address contractAddr)","event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)","function implementationOf(bytes32 contractName) view returns (address)","function owner() view returns (address)","function renounceOwnership()","function setImplementationForContract(address contractAddress)","function setImplementationWithId(bytes32 contractId, address contractAddress)","function transferOwnership(address newOwner)"],"stakepools/providers/HbarRewardRateProvider": ["function CONTRACT_ID() view returns (bytes32)","function contractId() view returns (bytes32)","function getRewardRatePerHbar() pure returns (uint256)"],"stakepools/providers/IHbarRewardRateProvider": ["function contractId() view returns (bytes32)","function getRewardRatePerHbar() view returns (uint256)"],"stakepools/providers/IRegistry": ["event ImplementationSet(bytes32 contractId, address contractAddr)","function implementationOf(bytes32 contractId) view returns (address)","function setImplementationForContract(address contractAddress)","function setImplementationWithId(bytes32 contractId, address contractAddress)"],"stakepools/providers/IRegistryElement": ["function contractId() view returns (bytes32)"],"stakepools/providers/IStakepoolPriceProvider": ["function contractId() view returns (bytes32)","function getPrice() returns (uint256)","function toTokenAmount(uint256 tinybars, uint256 tokenPriceTinycents) returns (uint256)"],"stakepools/providers/StakepoolHbarPriceProvider": ["function CONTRACT_ID() view returns (bytes32)","function contractId() view returns (bytes32)","function getPrice() returns (uint256)","function toTokenAmount(uint256 tinybars, uint256 tokenPriceTinycents) returns (uint256)"],"stakepools/utils/HederaMath": [],"stakepools/utils/TokenCreator": []
  };

export { AVAILABLE_NETWORK_NAMES, Account, ApiSession, CompileIssues, Contract, _hashgraphVenin_ContractRegistry as ContractRegistry, File, HEDERA_CUSTOM_NET_NAME, HederaNetwork, Json, KeyType, LiveAccount, LiveAccountWithPrivateKey, LiveContract, LiveContractWithLogs, LiveFile, LiveJson, LiveToken, LiveTopic, StratoAddress, Token, TokenType, TokenTypes, Topic, TypeOfExecutionReturn };
//# sourceMappingURL=hashgraph-venin-js.js.map
